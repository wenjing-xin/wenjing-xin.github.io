{"meta":{"title":"dreamChaser","subtitle":"希君生羽翼，一化北溟鱼","description":"生活很美，值得去记录，难道不是吗","author":"稳静逐梦","url":"https://wenjing-xin.github.io","root":"/"},"pages":[{"title":"404 Not found","date":"2024-02-06T04:02:26.000Z","updated":"2024-02-06T04:02:30.298Z","comments":true,"path":"404.html","permalink":"https://wenjing-xin.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2023-04-16T05:44:17.000Z","updated":"2024-02-15T15:22:31.723Z","comments":true,"path":"about/index.html","permalink":"https://wenjing-xin.github.io/about/index.html","excerpt":"","text":"我 一名普通的 IT 领域爱好者，平时喜欢写写代码，研究一些有趣的开源项目，闲暇之余浪迹与 GitHub、博客园、stackoverfolow 等各大平台。个人比较推崇前端模块化开发、组件化、工程化的开发，以 Java 为主要编程语言构建应用。 博客内容 此博客是我的个人博客，在这里，记录了我的技术博客、经验分享，也会分享我日常生活遇到的一些有趣的事和人。 不是每个人都可以做自己想做的事，成为自己想成为的人。 人生在世，必然会有自己的梦想，不论这个梦想是大还是小，是遥不可及还是触手可得，但是你所要坚信的只有一件事: 有梦想一定要去追，我们都是追梦人！不论现在处境如何，只要我们足够强，有些梦想并不是遥不可及 。我们都值得去拼一拼，有些事情不试试怎么知道你会不会成功？愿我们的所有汗水都有收获，所有的努力都不被辜负！"},{"title":"朋友圈","date":"2022-10-08T16:38:16.000Z","updated":"2024-02-20T14:59:09.037Z","comments":true,"path":"fcircle/index.html","permalink":"https://wenjing-xin.github.io/fcircle/index.html","excerpt":"","text":"let UserConfig = { // 填写你的 api 地址 private_api_url: 'https://fcircle.wenjing.xin/', // 初始加载几篇文章 page_init_number: 20, // 点击加载更多时，一次最多加载几篇文章，默认 10 page_turning_number: 10, // 头像加载失败时，默认头像地址 error_img: 'https://sdn.geekzu.org/avatar/57d8260dfb55501c37dde588e7c3852c', // 进入页面时第一次的排序规则 sort_rule: 'created', // 本地文章缓存数据过期时间（天） expire_days: 1, }"},{"title":"所有分类","date":"2023-04-16T05:43:53.000Z","updated":"2023-04-16T11:41:21.162Z","comments":true,"path":"categories/index.html","permalink":"https://wenjing-xin.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情连接🔗","date":"2023-04-16T05:46:14.000Z","updated":"2024-02-05T14:04:27.100Z","comments":true,"path":"friends/index.html","permalink":"https://wenjing-xin.github.io/friends/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2023-04-16T05:55:18.000Z","updated":"2023-04-16T11:40:41.278Z","comments":true,"path":"tags/index.html","permalink":"https://wenjing-xin.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2024-02-15T12:51:11.861Z","updated":"2024-02-15T11:28:42.360Z","comments":true,"path":"custom/darkmode.css","permalink":"https://wenjing-xin.github.io/custom/darkmode.css","excerpt":"","text":"#RightDownBtn { position: fixed; left: 1.875rem; bottom: 1.875rem; padding: 0.3125rem 0.625rem; background: #fff; border-radius: 0.1875rem; transition: 0.3s ease all; z-index: 1; align-items: flex-end; flex-direction: column; display: -moz-flex; display: flex; float: right; } #RightDownBtn>a, #RightDownBtn>label { width: 1.5em; height: 1.5em; margin: 0.3125rem 0; transition: .2s cubic-bezier(.25, .46, .45, .94); } /* font color */ .DarkMode #page, .DarkMode #colophon, .DarkMode #vcomments .vbtn, .DarkMode .art-content #archives .al_mon_list .al_mon, .DarkMode .art-content #archives .al_mon_list span, .DarkMode body, .DarkMode .art-content #archives .al_mon_list .al_mon, .DarkMode .art-content #archives .al_mon_list span, .DarkMode button, .DarkMode .art .art-content #archives a, .DarkMode textarea, .DarkMode strong, .DarkMode a, .DarkMode p, .DarkMode li, .DarkMode .label {color: rgba(255, 255, 255, .6); } .DarkMode #page, .DarkMode body, .DarkMode #colophon, .DarkMode #main-container, .DarkMode #page .yya, .DarkMode #content, .DarkMode #contentss, .DarkMode #footer {background-color: #292a2d;} .DarkMode strong, .DarkMode img {filter: brightness(.7); } /* sun and noon */ .Cuteen_DarkSky, .Cuteen_DarkSky:before { content: \"\"; position: fixed; left: 0; right: 0; top: 0; bottom: 0; z-index: 88888888 } .Cuteen_DarkSky {background: linear-gradient(#feb8b0, #fef9db) } .Cuteen_DarkSky:before { transition: 2s ease all; opacity: 0; background: linear-gradient(#4c3f6d, #6c62bb, #93b1ed) } .DarkMode .Cuteen_DarkSky:before {opacity: 1} .Cuteen_DarkPlanet { z-index: 99999999; position: fixed; left: -50%; top: -50%; width: 200%; height: 200%; -webkit-animation: CuteenPlanetMove 2s cubic-bezier(.7, 0, 0, 1); animation: CuteenPlanetMove 2s cubic-bezier(.7, 0, 0, 1); transform-origin: center bottom } @-webkit-keyframes CuteenPlanetMove { 0% {transform: rotate(0) } to {transform: rotate(360deg) } } @keyframes CuteenPlanetMove { 0% {transform: rotate(0) } to {transform: rotate(360deg) } } .Cuteen_DarkPlanet:after { position: absolute; left: 35%; top: 40%; width: 9.375rem; height: 9.375rem; border-radius: 50%; content: \"\"; background: linear-gradient(#fefefe, #fffbe8) }"},{"title":"","date":"2024-02-15T12:51:11.861Z","updated":"2024-02-15T11:29:21.627Z","comments":true,"path":"custom/darkmode.js","permalink":"https://wenjing-xin.github.io/custom/darkmode.js","excerpt":"","text":"function BackTOP() {$(\"#btn\").hide(); $(function () {$(window).scroll(function () {if ($(window).scrollTop()> 50) {$(\"#btn\").fadeIn(200); } else {$(\"#btn\").fadeOut(200); } }); $(\"#btn\").click(function () {$('body,html').animate({scrollTop: 0}, 500); return false; }); }); $(function () {$(\"#say\").click(function () {$('body,html').animate({scrollTop: $('html, body').get(0).scrollHeight }, 500); return false; }); }) } $('#readmode').click(function () {$('body').toggleClass('read-mode') }) function SiderMenu() {$('#main-container').toggleClass('open'); $('.iconflat').css('width', '50px').css('height', '50px'); $('.openNav').css('height', '50px'); $('#main-container,#mo-nav,.openNav').toggleClass('open') } function switchNightMode() {$('').appendTo($(\"body\")), setTimeout(function () {(volantis.dark.mode == \"dark\") ? ($(\"html\").addClass(\"DarkMode\"), $('#modeicon').attr(\"xlink:href\", \"#icon-sun\")) : ($(\"html\").removeClass(\"DarkMode\"), $('#modeicon').attr(\"xlink:href\", \"#icon-_moon\")), setTimeout(function () {$(\".Cuteen_DarkSky\").fadeOut(1e3, function () {$(this).remove()}) }, 2e3) }), 50 } function checkNightMode() {if ($(\"html\").hasClass(\"n-f\")) {$(\"html\").removeClass(\"day\"); $(\"html\").addClass(\"DarkMode\"); $('#modeicon').attr(\"xlink:href\", \"#icon-sun\") return; } if ($(\"html\").hasClass(\"d-f\")) {$(\"html\").removeClass(\"DarkMode\"); $(\"html\").addClass(\"day\"); $('#modeicon').attr(\"xlink:href\", \"#icon-_moon\") return; } if (volantis.dark.mode == \"dark\") {$(\"html\").addClass(\"DarkMode\"); $('#modeicon').attr(\"xlink:href\", \"#icon-sun\") } else {$(\"html\").removeClass(\"DarkMode\"); $('#modeicon').attr(\"xlink:href\", \"#icon-_moon\") } } BackTOP(); volantis.dark.push(switchNightMode);"},{"title":"","date":"2024-02-15T14:02:35.309Z","updated":"2024-02-15T13:58:10.468Z","comments":true,"path":"custom/subtitle.js","permalink":"https://wenjing-xin.github.io/custom/subtitle.js","excerpt":"","text":"var binft = function (r) { var isTransparent = true; function getRandomColor() {if(isTransparent){ isTransparent = false; // 此处修改字体颜色, 最后的 0 和 1 不要改 return \"rgba(90,144,224,0)\" }else{ isTransparent = true; return \"rgba(90,144,224,1)\" } } function n(r) {for (var n = document.createDocumentFragment(), i = 0; r > i; i++) {var oneword = document.createElement(\"span\"); oneword.textContent = \"|\"; // 此处是末尾字符, 如果想用光标样式可以改为 \"|\" oneword.style.color = getRandomColor(); n.appendChild(oneword); } return n } function i() {var t = wordList[c.skillI]; c.step ? c.step-- : (c.step = refreshDelayTime, c.prefixP < l.length ? (c.prefixP>= 0 && (c.text += l[c.prefixP]), c.prefixP++) : \"forward\" === c.direction ? c.skillP 0 ? (c.text = c.text.slice(0, -1), c.skillP--) : (c.skillI = (c.skillI + 1) % wordList.length, c.direction = \"forward\")), r.textContent = c.text, r.appendChild(n(c.prefixP < l.length ? Math.min(maxLength, maxLength + c.prefixP) : Math.min(maxLength, t.length - c.skillP))), setTimeout(i, d) } var l = \"\", // 此处改成你自己的诗词 wordList = [ \"有花堪折直需折, 莫待无花空折枝.\", \"闲居少邻并, 草径入荒园. 鸟宿池边树, 僧敲月下门.\", \"侯门一入深如海, 从此萧郎是路人.\", \"才见岭头云似盖, 已惊岩下雪如尘.\", \"人间万事消磨尽, 只有清香似旧时.\", \"日暮酒醒人已远, 满天风雨下西楼.\", \"落灯花, 棋未收, 叹新丰逆旅淹留.\", \"软风吹过窗纱, 心期便隔天涯.\", \"迷惑失故路, 薄暮无宿栖.\", \"不见白头相携老, 只许与君共天明.\", \"晓迎秋露一枝新, 不占园中最上春.\", \"荷尽已无擎雨盖, 菊残犹有傲霜枝.\", \"春未绿, 鬓先丝. 人间别久不成悲.\", \"江东子弟多才俊, 卷土重来未可知.\", \"莫听穿林打叶声, 何妨吟啸且徐行.\", \"在天愿作比翼鸟, 在地愿为连理枝.\", \"问世间情为何物. 直教人生死相许.\", \"轻舟已过万重山.\", \"岁月了无痕. 时光轻染故事尘. 百年光景如梦航. 笔墨留香绘干行.\", ].map(function (r) {return r + \"\"}), showTotalWordDelayTime = 3, refreshDelayTime = 2, maxLength = 1, d = 75, c = { text: \"\", prefixP: -maxLength, skillI: 0, skillP: 0, direction: \"forward\", delay: showTotalWordDelayTime, step: refreshDelayTime }; i()}; binft(document.getElementById('binft'));"},{"title":"","date":"2024-02-15T13:21:58.803Z","updated":"2024-02-15T13:21:58.803Z","comments":true,"path":"custom/dynamicTitle.js","permalink":"https://wenjing-xin.github.io/custom/dynamicTitle.js","excerpt":"","text":"var OriginTitle = document.title; document.addEventListener('visibilitychange', function () {if (document.hidden) {document.title = '╭(°A°`)╮ 你去哪了? 快回来!!!'; }else {document.title = '(ฅ>ω"}],"posts":[{"title":"基础篇：容器化部署技术 -—docker，从此摆脱多环境配置的苦恼！","slug":"docker","date":"2024-01-17T10:05:00.000Z","updated":"2024-02-16T07:27:56.233Z","comments":true,"path":"posts/40064/","link":"","permalink":"https://wenjing-xin.github.io/posts/40064/","excerpt":"","text":"前言 我们设想这样一个场景，现在 leader 给了你一个任务，让你把开发完毕的应用程序进行打包、分发、部署，要求多平台通用，程序的前后端是单独的工程、后端依赖了 mysql、redis、RabbitMQ 等。按常规的运维思路就是，先将配置好的前后端程序分别打包 --&gt; 将打包文件上传到服务器 --&gt; 后端安装 mysql、redis、RabbitMQ --&gt; 配置 nginx 服务器实现反向代理，虽然看上去步骤很简单，顺利部署成功，也不算太糟心，但是保不齐部署的时候，就会出现各种环境上的不兼容问题。此外，当一个程序依赖了五个、六个或者更多的环境时，按照这种传统的部署方式显然很繁琐，一旦遇到环境上的冲突、不兼容等问题，不禁让人陷入苦恼之中。假如有这样一种工具，能够将程序依赖的环境根据层级关系进行一个叠加 ，比如一个 Java 应用程序最底层肯定依赖的是 JDK，接着是一些数据库、中间件等其他环境，最后就是我们运行这个程序的一些入口，将这些环境根据层级关系叠加在一起，我们暂且将其称为安装包吧！ 而且这些安装包已经有人已经制作完毕并发布到公共仓库里边，当我们在部署我们的应用时，只需要按照这种工具规定的方式拉取安装包，部署岂不是方便很多了， docker 就应运而生了！ 一、什么是 Docker? docker 是一款可以为应用程序进行打包、分发、部署的工具，也可以理解为一个轻量的虚拟机，只需要虚拟机软件运行的环境，多余的一点都不需要。而 docker 可以帮助我们下载应用镜像，创建并运行镜像的容器，从而快速部署应用。对于上边提到的打包、分发、部署、镜像、容器这些概念，屏幕前的你是否会有些疑惑？ 打包：就是将软件所需要的依赖，第三方库，软件包打包到一起，变成一个安装包。 分发：你可以把你打包好的 &quot; 安装包 &quot; 上传到一个镜像仓库，其他人可以非常方便的获取和安装。 部署：拿着 &quot; 安装包 &quot;，就可以一行命令运行起来你的应用，在不同的平台上自动模拟出一摸一样的运行环境。 镜像 （image）： 将应用所需的函数库、依赖、配置等与应用一起打包得到的就是镜像 。更加官方的说法就是：镜像是一个包含程序运行必要依赖环境和代码的只读文件，它采用分层的文件系统，将每一层的改变以读写层的形式增加到原来的只读文件上。哈哈，官方说法看来很晦涩难懂呀， 我们只需要把它认为是一个安装包就行，随着使用的增加和深入，慢慢会理解的。 容器（container）：为每个镜像的应用创建的隔离运行环境就是容器，说白了就是一个进程。 镜像仓库（repository）：存储和管理镜像的服务就是镜像仓库，目前，DockerHub 是最大的镜像仓库，其中包含各种常见的应用镜像。 对于镜像和容器之间的关系我们需要有一定的了解，是非常重要的概念，是我们学习 docker 的基础 ，当然，我也不可能通过上边两个简单的概念就可以讲明白这两者之间的概念。打个比方吧， 镜像（image）好比面向对象编程语言里边的类，而容器 (container)好比面向编程语言里类实例化后的对象。一个类可以有多个对象，同理，一个镜像可以有多一个容器。容器是由镜像实例话而来，简单来说，镜像就是文件，容器就是进程。说到这里，你应该对两者的概念和关系有初步的理解了吧，镜像就是容器运行的基础，两者是辩证统一的关系。谈到这里，不得不提一下 docker 的生命周期了，它主要由三部分组成：镜像 + 容器 + 仓库。 二、docker 的安装 桌面版 服务器版 桌面版和服务器版的区别就是桌面版有 docker-compose 这个工具，而服务器版本没有，建议安装桌面版。 对于 mac 用户，可以使用 homebrew 安装，但是前提你得有 homebrew 安装工具，关于这个工具的安装，自行搜索网上的教程安装。当你电脑有 homebrew 时，直接用下面的命令行安装： 1brew install --cask docker 三、docker 常用命令 当我们的电脑上安装了 docker 之后，接着我们便可以使用 docker 来安装软件，在此处，我们以安装 mysql 为例来认识 docker 的基本命令。 在终端输入上述命令之后，就会安装好 mysql。关于这条命令的解读如下： docker run ：创建并运行一个容器，-d 是让容器在后台运行 –name mysql ：给容器起个名字，必须唯一 -p 3306:3306 ：设置端口映射 -e KEY=VALUE ：是设置环境变量 mysql 指定映射镜像运行的名称。镜像命名一般格式为：镜像名称: 镜像版本 ==&gt; [repository]: [tag]，在没有指定版本的时候，默认是 latest 最新版本。通过上边的小例子我们算是对 docker 的命令有了一定的了解，下边这张图是对 docker 命令的一个概述： &nbsp;docker 的其他命令，查看请展开 命令 具体作用 docker pull 将远程镜像仓库的镜像拉取到本地镜像中，类似于 git 的推送，注意在拉取镜像到本地后，镜像已经开始运行了 docker push 将本地仓库的镜像推送到远程镜像仓库中，类似于 git 的推送 docker images 查看本地运行的镜像 docker rmi 删除本地的镜像，具体命令为 docker rmi -f 镜像名称 docker build 构建本地的镜像并运行 docker load 加载本地的镜像并运行 docker run 运行容器 docker logs 产看容器运行的日志 docker exec 进入容器内部 docker stop 停止容器运行 docker start 启动容器 docker ps 查看正在运行的容器 docker rm 删除容器 这里有一个技巧，命令的具体细节我们可以不记忆，可以通过 --help 指令来查看它的用法，比如 docker rm 删除容器，我们可以通过 docker rm --help 来查看他的具体用法： 从终端的命令我们可看到 docker rm -f 容器名称 就是删除掉一个运行中的容器。通过这种方法我们便可以不用在记忆这么多繁琐的命令，只知道具体的命令关键字即可。通过上边的学习，我们便可以拉取、删除、运行、查看镜像了。 四、容器目录挂载的方式 通过上边的学习我们可以通过 docker 拉取远程镜像来部署我们的应用，现在有这样一个需求，用 nginx 部署一个 vue 项目，我们首先做的是拉取 nginx 镜像，接着配置 nginx. conf 文件，然后将 vue 打包的应用上传到 nginx 上。那么，问题来了，我们上边提到容器是镜像的实例化对象，而镜像本身就是一个虚拟机，如何去修改配置文件和上传 vue 打包的文件。对于修改配置文件 nginx. conf，我们不妨使用命令 docker exec nginx 进入容器内部, 但是当我们使用 vi 编辑器的时候，发现容器内部不支持，我们上边提到过：docker 是一款可以为应用程序进行打包、分发、部署的工具，也可以理解为一个轻量的虚拟机，只需要虚拟机软件运行的环境，多余的一点都不需要 ，所以便不会存在 vi 了。假如我们本地存在这样一个目录，可以将修改的配置文件和 vue 打包文件同步到容器内部，那么就方便多了。因此，我们需要了解一个新的概念–数据卷， 它是一个虚拟目录，是容器内目录与宿主机目录之间映射的桥梁。 关于数据卷的详细命令，直接通过帮助指令在终端自行查看，这里只提供常用指令。 1docker volume --help // 查看其他数据卷指令 下边我将介绍三种目录挂载的方式： 1、volume 方式 由容器创建和管理，创建在宿主机上，所以删除容器不会丢失，官方推荐，更高效，Linux 文件系统，适合存储数据库数据，可以挂载多个容器。 当我们在创建并运行镜像的时候，可通过语法 -v 数据卷名称(自定义): 容器内目录 来挂载目录，容器创建的时候，如果发现挂载的数据卷不存在时，就会自动创建数据卷。 1docker run -d --name nginx -p 80:80 -v html:/usr/share/nginx/html nginx 我们在终端查看发现目录 html 挂载成功了。 其实，这个 html 目录位于你本地 docker 安装目录下的 volumes 目录内，比如 mac 上是这样的，orbstack 是 mac 电脑上一种内含 dockerde 轻量化软件，不必深究这个目录，只需要找到你的 docker 安装目录即可。 2、bind Mount 方式 直接把宿主机的物理目录映射到容器内，适合挂载代码目录和配置文件。而且是一种双向绑定，宿主机和容器内的内容都是同步的，也可以挂载到多个容器上。现在有这样一个需求： 查看 mysql 容器，判断是否有数据卷挂载，基于宿主机目录实现 MySQL 数据目录、配置文件、初始化脚本的挂载（查阅官方镜像文档） ①挂载 /root/mysql/data 到容器内的 /var/lib/mysql 目录 ②挂载 /root/mysql/init 到容器内的 /docker-entrypoint-initdb.d 目录 ③挂载 /root/mysql/conf 到容器内的 /etc/mysql/conf. d 目录 对于以上需求，我们可以使用 volume 方式挂载，但是由于涉及的配置文件过多，我们难免在各个过程都需要修改，需要保持本地配置文件和容器内的配置一致，尤为重要的一点是当我们用 volume 的挂载删除容器时，虽然挂载的目录还在，但是当再次运行容器时，挂载的目录名称变了，上次的数据就会丢失，数据便没有迁移过来 ，因此，我们便选用 bind mount 进行绑定。具体语法如下： 1-v 本地目录 : 容器内目录 在运行 docker run 命令的时候，便可以将这条命令加入到后边。具体执行如下： 12345678docker run -d \\ --name mysql \\-p 3306:3306 \\-e TZ=Asia/Shanghai \\-e MYSQL_ROOT_PASSWORD=123 \\-v /Users/username/code/dockerApp/mysql/data:/var/lib/mysql \\-v /Users/username/code/dockerApp/mysql/init:/docker-entrypoint-initdb.d \\-v /Users/username/code/dockerApp/mysql/conf:/etc/mysql/conf.d \\mysql 由于命令太长，这里使用了 \\ 将命令进行分割。在终端运行以上命令，如下图： 我们使用 docker inspect mysql 命令来查看容器的详细信息，这里只截取了挂载目录的信息，如下图： 从上图发现已经主机目录已经和容器目录映射成功了！ 3、tmpfs Mount 适合存储临时文件，存储在宿主机内存中，不可多容器共享。 以上就是我们常见的三种目录挂载方式，核心掌握前两种方法。 五、自定义镜像 通过以上的学习，我们可以通过别人制作好的镜像去部署一个应用了，但是我们如果要制作属于自己的镜像该怎么做？下边我们将通过一个例子来讲述如何制作一个镜像。镜像就是包含了应用程序、程序运行的系统函数库、运行配置等文件的文件包。构建镜像的过程其实就是把上述文件打包的过程。 每一个镜像结构都是根据其依赖关系的层级关系或者说是依赖范围大小分层的，分别有基础镜像，中间的每一层，入口层。 关于这些层之间的结构 docker 提供了一个描述文件 Dockfile ，它会说明每一层具体要执行哪些操作，帮我们自动构建镜像，常见指令如下： 具体指令的详细描述如下 (可以略过)： 123// FROM 指令FROM &lt;IMAGE&gt;FROM &lt;IMAGE&gt;:&lt;TAG&gt; 通过 FROM 指定的镜像名称必须是一个已经存在的镜像，这个镜像称之为基础镜像，必须位于 第一条非注释指令。 12// MAINTAINER 指令MAINTAINER &lt;NAME&gt; 指定镜像的作者信息，包含镜像的所有者和联系人信息 1234// RUN 指令 用于指定构建镜像时运行的命令，两种模式：RUN &lt;command&gt; (shell 模式)RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] (exec 模式) 多条 RUN 指令可以合并为一条： 1RUN yun install httpd &amp;&amp; yun install ftp 这样在构建的时候会减少产生中间层镜像 123// EXPOSE 指令 指定运行该镜像的容器使用的端口，可以是多个EXPOSE &lt;PORT&gt; 使用这个指令的目的是告诉应用程序容器内应用程序会使用的端口，在运行时还需要使用 -p 参数指定映射端口。这是 docker 处于安全的目的，不会自动打开端口。 1docker run -p 80 -d dockertest/dockerfile_build nginx -g &quot;daemon off&quot; 12345// CMD 指令// 用于提供容器运行的默认命令 如果在 docker run 时指定了运行的命令，则 CMD 命令不会执行。CMD 有如下三种模式：CMD &lt;command&gt; (shell 模式)CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] (exec 模式)CMD [&quot;param1&quot;, &quot;param2&quot;] (通常与 ENTRYPOINT 搭配指定 ENTRYPOINT 的默认参数) 1234567// ADD 和 COPY作用都是将文件或目录复制到 Dockerfile 构建的镜像中ADD &lt;src&gt; &lt;dest&gt;ADD [&quot;&lt;src&gt;&quot; &quot;&lt;dest&gt;&quot;] (适用与文件路径包含空格的情况)COPY &lt;src&gt; &lt;dest&gt;ADD [&quot;&lt;src&gt;&quot; &quot;&lt;dest&gt;&quot;] （适用于文件路径包含空格的情况） build 为镜像（安装包）和运行 1docker build -t repository(package name):tag . 我们可以基于 Ubuntu 基础镜像，利用 Dockerfile 描述镜像结构， 但是这样有点麻烦，我们可以基于 Ubuntu 基础镜像，利用 Dockerfile 描述镜像结构，直接基于 JDK 为基础镜像，省略前面的步骤。 当我们便写好了 Dockefile 文件后，可以直接使用一下命令来构建镜像： 1docker build -t 镜像名称 . -t ：是给镜像起名，格式依然是 repository: tag 的格式，不指定 tag 时，默认为 latest . ：是指定 Dockerfile 所在目录，如果就在当前目录, 则指定为 .。 六、网络（多容器通信） 对于前后端分离的应用，我们单独部署的时候需要配置跨域，而且每个应用都是一个单独的容器，默认情况下，所有容器都是以 bridge 方式连接到 Docker 的一个虚拟网桥上： 但是如果重新启动容器后，IP 地址就会发生变化，我们又得在配置文件中修改配置，如果能把变化的 IP 地址用一个变量代替了，这样即使重启应用后，我们在也不需要修改 IP 地址了，而这个变量就是容器名称，但是默认情况下是不能通过容器名互相访问的，这时候我们需要通过自定义网络，让它们加入同一个网络，便可以使用容器名互相访问了！ Docker 网络操作命令如下： 也可以在容器运行的时候创建网络，具体示例操作如下： 1docker run -d --name redis --netowrk test-net --network-alias redis redis:latest 七、docker-compose 通过上边的讲述，我们可以将一个项目中涉及的环境进行部署，但是这样的方式只能一个容器一个容器的单独部署运行，如果项目中涉及的容器比较多，效率就会很低，因此 docker 提供了一个工具 docker- compose。Docker Compose 通过一个单独的 docker-compose. yml 模板文件（YAML 格式）来定义一组相关联的应用容器，帮助我们实现多个相互关联的 Docker 容器的快速部署。 事实上，Dockerfile 描述文件中的指令和 docker-compose. yml 配置文件的内容是对应的。 当我们配置好了 docker-compose. yml 文件后，直接运行 docker compose [OPTIONS] [COMMAND] 命令部署并运行所有容器。 总结 上述内容可以帮助我们处理日常开发过程中碰到的部署问题，对于不是专业的运维工作人员而言，已经足够了。有了 docker 后，我们在部署应用，分享自己的软件的时候，再也不会因为计算机系统、环境冲突而引起的问题苦恼了，这么好的工具我们有什么理由不学习使用呢？","categories":[{"name":"运维","slug":"运维","permalink":"https://wenjing-xin.github.io/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://wenjing-xin.github.io/tags/docker/"},{"name":"容器化部署技术","slug":"容器化部署技术","permalink":"https://wenjing-xin.github.io/tags/%E5%AE%B9%E5%99%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E6%8A%80%E6%9C%AF/"}],"author":"稳静逐梦"},{"title":"浅谈前端发展史","slug":"浅谈前端发展史","date":"2023-10-18T01:35:00.000Z","updated":"2024-02-16T07:27:56.240Z","comments":true,"path":"posts/29678/","link":"","permalink":"https://wenjing-xin.github.io/posts/29678/","excerpt":"","text":"一、前端的发展历史 石器时代： 1990 年，第一个 Web 浏览器诞生了。这是前端这个技术的起点，代表这一年它出生了。后面的时间里，前端圈有很多里程碑事件。 1994 年，网景公司发布第一个商业浏览器 Navigator。 1995 年，网景工程师 Brendan Eich 用 10 天时间设计了 JavaScript，同年微软发布了 IE 浏览器，进而掀起了浏览器大战。 2002 年，IE 在浏览器大战中赢得胜利，IE6 占有率超过 96% 而前端的发展历史，又非常直观地显示在你看到的前端网页的演变历史中。整个 90 年代，受限于网速，网页都是静态页，显示非常单一，前端的工作大部分都只是让美工来切切图和写写 HTML+CSS。也因此，在 90 年代，前端还处在一种萌发期的状态，前端工程师这一工种也没有明确出现。 再后来，后端越来越复杂，开始分层。就像在小公司里，大家啥都干，但公司规模大了之后，就要分部门，职责明确，代码也从揉在一起发展到 Model，View 和 Controller，分别负责不同的功能。 这就是后端 MVC 模式的盛行，让我们可以在模板里写上要展现的数据。以前的代码都是所有内容写在一起，现在就会用 Model 负责数据。 所以这个时代的网页主要还是以显示数据和简单的特效为主，比如当时众多的门户网站，也都没有太多的用户交互，主要就是显示后端存储的新闻。 直到 2004 年，Google 发布了 Gmail，用户可以在不刷新页面的情况下进行复杂的交互，之后，Ajax 逐渐成为网页开发的技术标准，也不断地被应用于各种网站。**Ajax 这个技术让我们可以异步的获取数据并且刷新页面，从此前端不再受限于后端的模板，这也宣告了 Web2.0 时代正式到来。** 至此，前端工程师也正式作为一个独立工种出现。 铁器时代 : 在 Gmail 诞生后，虽然依然有浏览器的混战和兼容性问题，比如绑定事件不同的浏览器就要写不同的代码，但大家意识到前端也可以做出复杂应用。而 jQuery 的出现迅速风靡全球，一个 $ 走天下，学会 jQuery 就等同于学会了前端，算是前端车同轴的时代。在这之后，前端的具体开发不再被 JavaScript 的兼容性问题所困扰。 那个时候 jQuery+Bootstrap 一把梭，成为了前端开发领域的主流技术，前端代码内嵌在后端的项目中，写完直接发布，通篇都是如下的代码： 123$(&#x27;#alert-btn&#x27;).on(&#x27;click&#x27;,function()&#123; $(&#x27;#app .input&#x27;).val(&#x27;hi&#x27;)&#125;) 那个时候写代码，就是找到某个元素，进行 DOM 操作，特别像铁器时代的拼刺刀，随着前端项目规模的逐渐提升，前端也需要规模化的时候，在 2009 年 AngularJS 和 Node.js 的诞生，也宣告前端工业革命的到来。 工业时代: AngularJS 的诞生，引领了前端 MVVM 模式的潮流；Node.js 的诞生，让前端有了入侵后端的能力，也加速了前端工程化的诞生。现在前端三大框架 Angular、React、Vue 的发展主线，也就是从这里开始的。 所谓 MVVM，就是在前端的场景下，把 Controller 变成了 View-Model 层，作为 Model 和 View 的桥梁，Model 数据层和 View 视图层交给 View-Model 来同步。 二、前端三大框架： 在前端 MVVM 模式下，不同框架的目标都是一致的，就是利用数据驱动页面，但是怎么处理数据的变化，各个框架走出了不同的路线。 这些框架要回答的核心问题就是，数据发生变化后，我们怎么去通知页面更新。各大框架在这个步骤上，各显神通： Angular 1 就是最老套的脏检查。所谓的脏检查，指的是 Angular 1 在对数据变化的检查上，遵循每次用户交互时都检查一次数据是否变化，有变化就去更新 DOM 这一方法。这个方法看似简单粗暴，但算是数据驱动页面早期的实现，所以一经推出，就迅速占领了 MVVM 市场。 后面 Angular 团队自断双臂，完全抛弃 Angular 1，搞了一个全新的框架还叫 Angular，引入了 TypeScript、RxJS 等新内容，虽然这些设计很优秀，但是不支持向前兼容，抛弃了老用户。这样做也伤了一大批 Angular 1 用户的心，包括我。这也是 Angular 这个优秀的框架现在在国内没有大面积推广的原因。 而 Vue 1 的解决方案，就是使用响应式，初始化的时候，Watcher 监听了数据的每个属性，这样数据发生变化的时候，我们就能精确地知道数据的哪个 key 变了，去针对性修改对应的 DOM 即可，这一过程可以按如下方式解构： 在上图中，左边是实际的网页内容，我们在网页中使用 &#123;&#123;&#125;&#125; 渲染一个变量，Vue 1 就会在内容里保存一个监听器监控这个变量，我们称之为 Watcher，数据有变化，watcher 会收到通知去更新网页。 通俗来说，如果把网页数据看成你管理的员工，普通数据就是那种每次你都需要找到他，告诉他要怎么做的人，响应式数据就是他本身有任何变化，都会主动给你发日报告诉你的积极员工。 此外，Facebook 的 React 团队提出了不同于上面的 Angular、Vue 的的解决方案，他们设计了 React 框架，在页面初始化的时候，在浏览器 DOM 之上，搞了一个叫虚拟 DOM 的东西，也就是用一个 JavaScript 对象来描述整个 DOM 树。我们可以很方便的通过虚拟 DOM 计算出变化的数据，去进行精确的修改。 我们先看 react 中的一段代码： 1234&lt;div id = &quot;app&quot;&gt; &lt;p class = &quot;item&quot;&gt;Item1&lt;/p&gt; &lt;div class = &quot;item&quot;&gt;Item2&lt;/div&gt;&lt;/div&gt; 在 React 中，这样一段 HTML 会被映射成一个 JavaScript 的对象进行描述。这个对象就像数据和实际 DOM 的一个缓存层，通过管理这个对象的变化，来减少对实际 DOM 的操作。 这种形式不仅让性能有个很好的保障，我们还多了一个用 JSON 来描述网页的工具，并且让虚拟 DOM 这个技术脱离了 Web 的限制。因为积累了这么多优势，虚拟 DOM 在小程序，客户端等跨端领域大放异彩。 虚拟 DOM 在运行的时候就是这么一个对象： 123456789101112131415161718&#123; tag: &quot;div&quot;, attrs: &#123; id: &quot;app&quot; &#125;, children: [ &#123; tag: &quot;p&quot;, attrs: &#123; className: &quot;item&quot; &#125;, children: [&quot;Item1&quot;] &#125;, &#123; tag: &quot;div&quot;, attrs: &#123; className: &quot;item&quot; &#125;, children: [&quot;Item2&quot;] &#125; ]&#125; 这个对象完整地描述了 DOM 的树形结构，这样数据有变化的时候，我们生成一份新的虚拟 DOM 数据，然后再对之前的虚拟 DOM 进行计算，算出需要修改的 DOM，再去页面进行操作。 浏览器操作 DOM 一直都是性能杀手，而虚拟 DOM 的 Diff 的逻辑，又能够确保尽可能少的操作 DOM，这也是虚拟 DOM 驱动的框架性能一直比较优秀的原因之一。 三、vue 和 react 框架的对比 通过上面对前端三大框架的介绍，我们不难发现 Vue 和 React 在数据发生变化后，在通知页面更新的方式上有明显的不同，通俗的来说，就是： 在 Vue 框架下，如果数据变了，那框架会主动告诉你修改了哪些数据；而 React 的数据变化后，我们只能通过新老数据的计算 Diff 来得知数据的变化。 这两个解决方案都解决了数据变化后，如何通知页面更新的问题，并且迅速地获得了很高的占有率，但是他们都碰到了性能的瓶颈： 对于 Vue 来说，它的一个核心就是“响应式”，也就是数据变化后，会主动通知我们。响应式数据新建 Watcher 监听，本身就比较损耗性能，项目大了之后每个数据都有一个 watcher 会影响性能。 对于 React 的虚拟 DOM 的 Diff 计算逻辑来说，如果虚拟 DOM 树过于庞大，使得计算时间大于 16.6ms，那么就可能会造成性能的卡顿。 为了解决这种性能瓶颈， Vue 和 React 走了不同的道路。 React 为了突破性能瓶颈，借鉴了操作系统时间分片的概念，引入了 Fiber 架构。通俗来说，就是把整个虚拟 DOM 树微观化，变成链表，然后我们利用浏览器的空闲时间计算 Diff。一旦浏览器有需求，我们可以把没计算完的任务放在一旁，把主进程控制权还给浏览器，等待浏览器下次空闲。 这种架构虽然没有减少运算量，但是巧妙地利用空闲实现计算，解决了卡顿的问题。你可以看一下图解： 在上图中，左侧是一个树形结构，树形结构的 Diff 很难中断；右侧是把树形结构改造成了链表，遍历严格地按照子元素 -&gt; 兄弟元素 -&gt; 父元素的逻辑，随时可以中断和恢复 Diff 的计算过程。 为了方便你对计算 Diff 的理解，我们来看下面这张图： 这个图里两个虚线之间是浏览器的一帧，高性能的动画要求是 60fps，也就是 1 秒要渲染 60 次，每一帧的时间就是 16.6 毫秒，在这 16.6 毫秒里，浏览器自己的渲染更新任务执行后，会有一部分的空闲时间，这段时间我们就用来计算 Diff。 等到下一帧任务来了，我们就把控制权还给浏览器，让它继续去更新和渲染，等待空闲时间再继续计算，这样就不会导致卡顿。 Vue 1 的问题在于响应式数据过多，这样会带来内存占用过多的问题。所以 Vue 2 大胆引入虚拟 DOM 来解决响应式数据过多的问题。 这个解决方案使用虚拟 DOM 解决了响应式数据过多的内存占用问题，又良好地规避了 React 中虚拟 DOM 的问题， 还通过虚拟 DOM 给 Vue 带来了跨端的能力。 响应式数据是主动推送变化，虚拟 DOM 是被动计算数据的 Diff，一个推一个拉，它们看起来是两个方向的技术，但被 Vue 2 很好地融合在一起，采用的方式就是组件级别的划分。 对于 Vue 2 来说，组件之间的变化，可以通过响应式来通知更新。组件内部的数据变化，则通过虚拟 DOM 去更新页面。这样就把响应式的监听器，控制在了组件级别，而虚拟 DOM 的量级，也控制在了组件的大小。 这个方案也体现了 Vue 一直以来坚持的中庸的设计思想。 下图左边就是一个个的组件，组件内部是没有 Watcher 监听器的，而是通过虚拟 DOM 来更新，每个组件对应一个监听器，大大减小了监听器的数量。 除了响应式和虚拟 DOM 这个维度，Vue 和 React 还有一些理念和路线的不同，在模板的书写上，也走出了 template 和 JSX 两个路线。 React 的世界里只有 JSX[[…/web/vue3/jsx 的基本使用]]，最终 JSX 都会在 Compiler 那一层，也就是工程化那里编译成 JS 来执行，所以 React 最终拥有了全部 JS 的动态性，这也导致了 React 的 API 一直很少，只有 state、hooks、Component 几个概念，主要都是 JavaScript 本身的语法和特性。关于 vuex 在 react 中的具体使用查看此篇：[[…/web/react/01-jsx]] 而 Vue 的世界默认是 template，也就是语法是限定死的，比如 v-if 和 v-for 等语法。有了这些写法的规矩后，我们可以在上线前做很多优化。Vue 3 很优秀的一个点，就是在虚拟 DOM 的静态标记上做到了极致，让静态的部分越过虚拟 DOM 的计算，真正做到了按需更新，很好的提高了性能。 在模板的书写上，除了 Vue 和 React 走出的 template 和 JSX 两个路线，还出现了 Svelte 这种框架，没有虚拟 DOM 的库，直接把模板编译成原生 DOM，几乎没有 Runtime，所有的逻辑都在 Compiler 层优化，算是另外一个极致。 总结： 1 了解了前端 MVVM 框架发展的历史和方向后，相信你脑海里已经建立起了一个前端框架发展的地图，每个框架都在探索自己的路线。后面还会涌现出更多优秀的框架，我们到时候只需要把那个框架纳入到这个地图中去理解，这样你很快就明白这个框架做了什么，而这也是很多前端大神能够快速学习一个新框架的主要原因。 浏览器的诞生让我们可以方便地显示文本和图片的内容和样式；JavaScript 的出现让网页动了起来；Gmail 的发布，宣告前端也可以使用 Ajax 异步加载技术，来进行复杂网页的开发，前端工程师这个工种也正式出现了。随着浏览器厂商的混战，各个浏览器都有自己的特色，jQuery 框架的出现统一了写法，解决了那个时代最棘手的前端问题：兼容性，极大提高了开发者的效率。 随着 Angular 1 的诞生，我们多了一套开发模式，就是数据驱动页面。我们甚至不再需要使用 jQuery 去寻找 DOM，而是只关注数据的来源和修改，这也就是现在我们所处的前端时代。我们所熟悉的 Vue、React、Angular 和 Svelte 等框架，都是在数据驱动页面这个场景下涌现的框架。 相信到这里，你已经大概明白前端的这些框架的风格和特点，以及 Vue 在这些框架中的地位，Vue 3 在 Vue 2 的基础之上做了全面的升级，在性能、扩展性和包的大小上，Vue3 都有质的飞跃。","categories":[{"name":"前端","slug":"前端","permalink":"https://wenjing-xin.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://wenjing-xin.github.io/tags/%E6%9D%82%E8%B0%88/"},{"name":"web","slug":"web","permalink":"https://wenjing-xin.github.io/tags/web/"}],"author":"稳静逐梦"},{"title":"深入 Java 泛型","slug":"深入Java泛型","date":"2023-07-18T12:03:00.000Z","updated":"2024-02-16T07:27:56.241Z","comments":true,"path":"posts/37782/","link":"","permalink":"https://wenjing-xin.github.io/posts/37782/","excerpt":"","text":"一、什么是 Java 的泛型？ Java 的泛型是 jdk1.5 引入的一个新特性，其特点就是将类型进行一个参数化，把类型作为参数传递。一些常见的泛型类型有： E 元素（Element），多用于 Java 集合框架 K 关键字（key） V 值（value） T 类型（Type） N 数字（Number） 语法： 1&lt;T,...&gt; //T 称为类型占位符，表示一种引用类型 好处： 提高代码的重用性 防止类型转换异常，提高代码的安全性 二、泛型的常见使用形式 1、泛型类 12345678910111213141516171819202122/** * 泛型类 * 语法：类名 &lt;T&gt; * T 是类型占位符，表示一种引用类型，如果编写多个使用逗号隔开 * @author: wb */public class MyGeneric&lt;T&gt; &#123; // 使用泛型 T //1 创建变量 T t; //2 作为方法的参数 public void show(T t)&#123; System.out.println(t); &#125; //3 使用泛型作为方法的返回值 public T getT()&#123; return t; &#125;&#125; 12345678910111213141516171819202122/** * @author: wb */public class TestGeneric &#123; public static void main(String[] args) &#123; // 使用泛型类创建对象 // 注意：1 泛型只能使用引用类型 2 不同泛型对象之间不能相互赋值 MyGeneric&lt;String&gt; myGeneric = new MyGeneric&lt;&gt;(); myGeneric.t = &quot;hello world&quot;; myGeneric.show(&quot; 字符串泛型 &quot;); String string = myGeneric.getT(); System.out.println(string); MyGeneric&lt;Integer&gt; myGeneric2 = new MyGeneric&lt;&gt;(); myGeneric2.t = 1024; myGeneric2.show(65536); Integer integer = myGeneric2.getT(); System.out.println(integer); &#125;&#125; 打印结果： 1234 字符串泛型 hello world655361024 2、泛型接口 123456789101112/** * 泛型接口 * 语法：接口名 &lt;T&gt; * 注意：不能创建泛型静态常量 * @author: wb */public interface MyInterface&lt;T&gt; &#123; String name = &quot; 张三 &quot;; T server(T t);&#125; 泛型接口的实现方式一： 1234567891011/** * @author: wb */public class MyInterfaceImpl implements MyInterface&lt;String&gt; &#123; @Override public String server(String s) &#123; System.out.println(s); return s; &#125;&#125; 泛型接口的实现方式二： 1234567891011/** * @author: wb */public class MyInterfaceImpl2&lt;T&gt; implements MyInterface&lt;T&gt; &#123; @Override public T server(T t) &#123; System.out.println(t); return t; &#125;&#125; 测试 12345678910111213/** * @author: wb */public class TestGeneric &#123; public static void main(String[] args) &#123; // 泛型接口 MyInterfaceImpl impl = new MyInterfaceImpl(); impl.server(&quot;hello world&quot;); MyInterfaceImpl2&lt;Integer&gt; impl2 = new MyInterfaceImpl2(); impl2.server(1024); &#125;&#125; 控制台打印结果： hello world 1024 3、泛型方法 12345678910111213/** * 泛型方法 * 语法：&lt;T&gt; 返回值类型 * @author: wb */public class MyGenericMethod &#123; // 泛型方法 public &lt;T&gt; T show(T t)&#123; System.out.println(&quot; 泛型方法 &quot; + t); return t; &#125;&#125; 调用方法： 12345678910111213141516public class TestGeneric &#123; public static void main(String[] args) &#123; // 泛型方法 MyGenericMethod myGenericMethod = new MyGenericMethod(); myGenericMethod.show(&quot; 我的祖国 &quot;); myGenericMethod.show(123); myGenericMethod.show(3.14); &#125;&#125;/*** 控制台打印结果：* 泛型方法我的祖国 * 泛型方法 123* 泛型方法 3.14*/ 3、泛型集合 概念：参数化类型的集合、类型安全的集合，强制集合元素的类型必须一致。优点： 编译时检查，而非运行时抛出异常。 访问时，不必类型转换 不同泛型引用之间不能相互赋值，Java 集合中没有 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * @author: wb */public class Demo3 &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(); arrayList.add(&quot;xxx&quot;); arrayList.add(&quot;yyy&quot;); for (String s : arrayList) &#123; System.out.println(s); &#125; ArrayList&lt;Student&gt; arrayList2 = new ArrayList&lt;Student&gt;(); Student s1 = new Student(&quot; 张三 &quot;, 21); Student s2 = new Student(&quot; 里斯 &quot;, 23); Student s3 = new Student(&quot; 王五 &quot;, 24); arrayList2.add(s1); arrayList2.add(s2); arrayList2.add(s3); Iterator&lt;Student&gt; it = arrayList2.iterator(); while (it.hasNext()) &#123; Student next = it.next(); System.out.println(next); &#125; &#125;&#125;/*** 学生类 * @author wb*/class Student&#123; private String name; private String age; public Student(String name, int age)&#123; this.name = name; this.age = age; &#125; public void setName(String name)&#123; this.name =name; &#125; public Stirng getName(String name)&#123; return this.name; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://wenjing-xin.github.io/categories/Java/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://wenjing-xin.github.io/tags/JavaSE/"}],"author":"稳静逐梦"},{"title":"或许世人道你轻狂，可你本就年少啊！","slug":"或许世人道你轻狂，可你本就年少啊！","date":"2023-07-17T11:49:00.000Z","updated":"2024-02-16T07:27:56.238Z","comments":true,"path":"posts/49114/","link":"","permalink":"https://wenjing-xin.github.io/posts/49114/","excerpt":"","text":"作为年轻的 00 后，看护好我们自己的激情更理想，的确很重要，因为我们知道终将有一天都会消磨。 我们或许太早看到过自己不曾到达的世界，这或许是一种幸福，也或许是一种悲哀。","categories":[{"name":"思考","slug":"思考","permalink":"https://wenjing-xin.github.io/categories/%E6%80%9D%E8%80%83/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://wenjing-xin.github.io/tags/%E9%9A%8F%E7%AC%94/"}],"author":"稳静逐梦"},{"title":"来得及！","slug":"来的及！","date":"2023-07-12T15:32:00.000Z","updated":"2024-02-16T07:27:56.239Z","comments":true,"path":"posts/51240/","link":"","permalink":"https://wenjing-xin.github.io/posts/51240/","excerpt":"","text":"从小到大，家里的墙上一直挂着一份字画，其中有两句我从小记到大：“孩儿立志出乡门，学不成名终不还”。虽然这句话有点夸大，但是成长悄然无息， 我逐渐在长大，有了自己认为值得去做的事情，慢慢和父母相处的时间也逐渐在缩短，我总是认为来得及，以后一定有时间陪伴父母，但是当我发现母亲眼角的皱纹，慈祥笑容隐藏下的思念后，我内心倍感自责，只是因为学业和自己的目标去忙碌而忽视了身边最亲的人，我想就算最后自认为很充实，但也极其愚蠢。重要的事情是有很多，但是对亲人的陪伴也很重要，自己这种认为一切来得及的念头更加无知愚昧，有些事情是不能拖，但陪伴父母、孝顺父母更不能拖！","categories":[{"name":"随笔记录","slug":"随笔记录","permalink":"https://wenjing-xin.github.io/categories/%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"亲情","slug":"亲情","permalink":"https://wenjing-xin.github.io/tags/%E4%BA%B2%E6%83%85/"}],"author":"稳静逐梦"},{"title":"技术和浪漫","slug":"技术和浪漫","date":"2023-07-01T15:01:00.000Z","updated":"2024-02-16T07:27:56.238Z","comments":true,"path":"posts/45621/","link":"","permalink":"https://wenjing-xin.github.io/posts/45621/","excerpt":"","text":"如果技术是星辰大海，代码就是这个时代最浪漫的诗。 诗人用诗歌传情，画家用绘画表意， 而千万行代码和跨越山海的链接在键盘上留下的余温， 是程序员内心最深处独有的浪漫主义。 😁","categories":[{"name":"随笔记录","slug":"随笔记录","permalink":"https://wenjing-xin.github.io/categories/%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://wenjing-xin.github.io/tags/%E9%9A%8F%E7%AC%94/"}],"author":"稳静逐梦"},{"title":"因果与平衡","slug":"因果与平衡","date":"2023-06-25T15:07:00.000Z","updated":"2024-02-16T07:27:56.236Z","comments":true,"path":"posts/18352/","link":"","permalink":"https://wenjing-xin.github.io/posts/18352/","excerpt":"","text":"在这个宇宙中，无论是生物、自然界还是人类社会，因果与平衡都是普遍存在的规律。它们相互作用，塑造着我们的生活和世界。当我们深入探讨这些规律时，我们会发现，万事万物都在追寻着某种平衡点。一个生态系统、一个生命个体，乃至一个微观粒子，都在努力寻找并维持这种平衡。 因果关系是宇宙中的一种基本原理。在生活中，我们经常会说“因果报应”，意味着一个人的行为会带来相应的结果。然而，因果关系并不仅限于道德层面。在科学和自然界，因果关系也是无处不在的。从物理学的牛顿第三定律到生物学的遗传学，它们都反映了因果规律在不同层面上的体现。 然而，在这个复杂的世界中，因果关系往往并非一对一的简单关系。事物之间的相互作用是错综复杂的，其中的因果关系可能是多对多，甚至是循环往复。在这种情况下，平衡的概念便显得尤为重要。 平衡是一种自然的状态。当事物达到平衡状态时，它们就能够和谐共处，相互制衡，维持稳定。无论是自然界和人类社会的平衡维持机制，还是我们个人如何以自己的理念保持这种平衡，我们可以将平衡视为是因果关系的一种表现形式。一个稳定的系统往往具有良好的因果关系，使得各个因素能够在动态变化中找到恰当的位置。 我们可以将因果和平衡联系起来，以更好地理解万事万物的规律。在生活中，我们常常会遇到各种问题和挑战。理解因果和平衡的关系有助于我们从更广阔的视角审视问题，找到问题的根源，并采取适当的措施来恢复平衡。这种思维方式能够帮助我们更好地应对生活中的困境，实现个人和社会的和谐发展。","categories":[{"name":"思考","slug":"思考","permalink":"https://wenjing-xin.github.io/categories/%E6%80%9D%E8%80%83/"}],"tags":[{"name":"世界","slug":"世界","permalink":"https://wenjing-xin.github.io/tags/%E4%B8%96%E7%95%8C/"}],"author":"稳静逐梦"},{"title":"做自己想做的事情，别太在意别人的看法","slug":"做自己想做的事情，别太在意别人的看法","date":"2023-06-15T14:44:00.000Z","updated":"2024-02-16T07:27:56.234Z","comments":true,"path":"posts/7618/","link":"","permalink":"https://wenjing-xin.github.io/posts/7618/","excerpt":"","text":"在我们追求理想和目标的道路上，只要所做之事不违法、不违背道德和良心，并且有益于社会，那么无论何时都值得去努力。你的热情和喜爱不应被他人的眼光所束缚，也不应受限于他人的评价。他人的支持、评价、劝说和安排都是有局限性的，我们不应该盲从他人，而应该勇敢地追求自己的梦想。换言之，这个世界赋予我们的未必丰富，但我们不应过分关注他人的看法。 如果当年马云过分在意他人的看法，阿里巴巴或许早已消失；如果比尔·盖茨太过拘泥于他人的观点而没有退学创办微软，我们现今的科技世界也许大不相同。所以， 请珍视内心的声音，让生命之花在勇敢追求梦想的道路上绽放 。","categories":[{"name":"思考","slug":"思考","permalink":"https://wenjing-xin.github.io/categories/%E6%80%9D%E8%80%83/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://wenjing-xin.github.io/tags/%E9%9A%8F%E7%AC%94/"}],"author":"稳静逐梦"},{"title":"爱和勇气","slug":"爱和勇气","date":"2023-06-02T14:52:00.000Z","updated":"2024-02-16T07:27:56.240Z","comments":true,"path":"posts/43678/","link":"","permalink":"https://wenjing-xin.github.io/posts/43678/","excerpt":"","text":"我认识的一个人，就是一个无比理性的人。 越是亲密关系，他就越心口不一，他的心是感性的，脑子却是理性的。 无论是亲情还是爱情，好像没什么可以真正伤害到他。 他好像没有心一样，但矛盾的是，他比谁都在乎这些感情。 他永远在倾听别人，自己却不敢讲的太多。 你觉得他冷漠孤傲，其实是带有自卑的理性。 所以他不会有那种“因为爱所以爱”的浪漫情节。 但会有“因为爱所以放弃”的悲惨结局。 他只有清楚的看到对方的坚定，才敢于让内心的感性来支配自己。 这是一种由内而外的爱和勇气。","categories":[{"name":"思考","slug":"思考","permalink":"https://wenjing-xin.github.io/categories/%E6%80%9D%E8%80%83/"}],"tags":[{"name":"情感","slug":"情感","permalink":"https://wenjing-xin.github.io/tags/%E6%83%85%E6%84%9F/"}],"author":"稳静逐梦"},{"title":"软件开发者应该具备的基本提问素质","slug":"软件开发者应该具备的基本提问素质","date":"2023-05-26T07:33:00.000Z","updated":"2024-02-16T07:27:56.242Z","comments":true,"path":"posts/38104/","link":"","permalink":"https://wenjing-xin.github.io/posts/38104/","excerpt":"","text":"提问的基本注意事项 说明你的问题，详细说明，并且说明你是怎么做的，尝试过哪些解决方案，搜寻过哪些东西，然后为什么没有解决，发现了什么问题，你输入了什么命令，你在终端里，能否复制完整的终端 log，这样才好定义问题所在。 否则，一个问题导致的可能性实在是太多了，如果给的信息只有几个字，那我只有用经验去尝试，但是你知道，这样的效率往往是最低的。 在提问问题之前，一定要明白自己做了什么，自己尝试了什么， 自己截图截下来，然后网上搜索了什么，还是没有解决或者是产生了什么新的问题，自己用的到底是什么版本，软件版本，系统版本，产生问题软件的版本（系统和软件信息）…这些东西描述清楚，并且伴随截图，一条信息发送给别人，这样别人才好定位问题。","categories":[{"name":"思考","slug":"思考","permalink":"https://wenjing-xin.github.io/categories/%E6%80%9D%E8%80%83/"}],"tags":[{"name":"程序人生","slug":"程序人生","permalink":"https://wenjing-xin.github.io/tags/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"}],"author":"稳静逐梦"},{"title":"远征、流浪","slug":"远征、流浪","date":"2023-05-10T03:33:00.000Z","updated":"2024-02-16T07:27:56.242Z","comments":true,"path":"posts/64988/","link":"","permalink":"https://wenjing-xin.github.io/posts/64988/","excerpt":"","text":"远征、流浪，远离家乡，脱离你的依赖环境 远离家乡，才能远征。","categories":[{"name":"随笔记录","slug":"随笔记录","permalink":"https://wenjing-xin.github.io/categories/%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://wenjing-xin.github.io/tags/%E9%9A%8F%E7%AC%94/"}],"author":"稳静逐梦"},{"title":"探索","slug":"探索","date":"2023-05-01T17:12:00.000Z","updated":"2024-02-16T07:27:56.238Z","comments":true,"path":"posts/12059/","link":"","permalink":"https://wenjing-xin.github.io/posts/12059/","excerpt":"","text":"永远不要丧失探索的欲望！ 生命不息，探索不止。年轻人应当如此！ 最后，引用一句大佬的话，送给看到这句话的朋友： 我认为，应该放弃那些虚有其表的东西，追求真实的生活。荣誉和面子都不应该成为你关心的重点。你要关注的是，你在未来的 3~4 年里能够做些什么，以及你已经做了哪些事情。我们这个行业与其他行业不同，你可能需要一个好的笔记本电脑、一个好的键盘和一个健康的身体。此外，你需要一个稳固的探索心态，并且不断努力跳出思维定式。这才是成功的关键。","categories":[{"name":"随笔记录","slug":"随笔记录","permalink":"https://wenjing-xin.github.io/categories/%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://wenjing-xin.github.io/tags/%E9%9A%8F%E7%AC%94/"}],"author":"稳静逐梦"},{"title":"创造力","slug":"感想","date":"2023-04-15T16:58:00.000Z","updated":"2024-02-16T07:27:56.237Z","comments":true,"path":"posts/32983/","link":"","permalink":"https://wenjing-xin.github.io/posts/32983/","excerpt":"","text":"社会总是用激进竞争的话语来诱惑年轻人需要奋力向上，但是事实上这剥夺了年轻人自由选择生活和发现创造性的权利。所以我们这十六年多的学习旅途中，真的获得创造力了吗？","categories":[{"name":"随笔记录","slug":"随笔记录","permalink":"https://wenjing-xin.github.io/categories/%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://wenjing-xin.github.io/tags/%E9%9A%8F%E7%AC%94/"}],"author":"稳静逐梦"},{"title":"程序的本质：代码是如何被执行的","slug":"程序的本质：代码是如何被执行的","date":"2023-04-10T06:14:00.000Z","updated":"2024-02-16T07:27:56.241Z","comments":true,"path":"posts/42158/","link":"","permalink":"https://wenjing-xin.github.io/posts/42158/","excerpt":"","text":"一、解释型、编译型、混合型语言 要回答上述问题，我们要从最基础的讲起。 我们知道，CPU 只认识机器指令（也叫做 CPU 指令、机器码），用像 Python、C++、Java 这样的高级语言编写的代码，需要编译（编译的意思实际上就是“翻译”）为机器指令之后，才能被 CPU 执行。而不同类型的语言，其编译过程也是不同的，据此我们将其分为三类。 1 ）编译型语言 对于类似 C++ 这样的编译型语言，代码会事先被编译成机器指令（可执行文件），然后再一股脑儿交给 CPU 来执行。在执行时，CPU 面对是已经编译好的机器指令，直接逐条执行即可，执行效率比较高。但因为每种类型的 CPU（比如 Intel、ARM 等）支持的 CPU 指令集不同，并且程序还有可能调用操作系统提供的 API，所以，编译之后的可执行文件只能在特定的操作系统和机器上执行，换一种操作系统或机器，编译之后的可执行文件就无法执行了。 CPU 架构 是 CPU 厂商给属于同一系列的 CPU 产品定的一个规范，主要目的是为了区分不同类型 CPU 的重要标示。目前市面上的 CPU 分类主要分有两大阵营，一个是 intel、AMD 为首的复杂指令集 CPU，另一个是以 IBM、ARM 为首的精简指令集 CPU。两个不同品牌的 CPU，其产品的架构也不相同，例如，Intel、AMD 的 CPU 是 X86 架构的，而 IBM 公司的 CPU 是 PowerPC 架构，ARM 公司是 ARM 架构。 2 ）解释型语言 对于类似 Python 这样的解释型语言，代码并不会被事先编译成机器指令，而是在执行的过程中，由 Python 虚拟机（也叫做解释器）逐条取出程序中的代码，编译成机器指令，交由 CPU 执行，完成之后，再取出下一条代码，重复上述的编译、执行过程。这种 一边编译一边执行的过程，叫做解释执行。 解释型语言相对于编译型语言，执行速度会慢一些。因为程序是在执行的过程中一边编译一边执行的，所以，程序整体的执行时间包含了程序编译的时间。不过，使用解释性语言编写的代码，可移植性更好 。程序在执行的过程中， 虚拟机可以根据当前所在机器的 CPU 类型和操作系统类型，翻译成不同的 CPU 指令。这样，同一份代码就可以运行在不同类型的机器和不同类型的操作系统上。这就是常听到的“一次编写，多处运行”。 3）混合型语言 Java 语言比较特殊，它属于混合型语言，既包含 编译执行也包含解释执行。 Java 编译器会先将代码（.java 文件）编译成字节码（.class 文件 ）而非机器码，字节码算是 Java 代码的一种中间状态，其跟平台无关，但又可以快速地被翻译成机器码。编译之后的字节码在执行时，仍然是解释执行的，也就是逐行读出字节码，然后翻译成机器码，再交给 CPU 执行。只不过， 从字节码到机器码的翻译过程，比从高级语言到机器码的翻译过程，耗时要少。这样既保证了 Java 代码的可移植性（同一份代码可以运行在不同的 CPU 和操作系统上），又避免了解释执行效率低的问题。 实际上，在解释执行时，也存在编译执行。Java 虚拟机会将热点字节码（反复多次执行的代码，类似缓存中的热点数据），编译成机器码缓存起来，以供反复执行，这样就避免了热点字节码反复编译，进一步节省了解释执行的时间。这就是著名的 JIT 编译（Just In Time Compile，即时编译），这部分内容会在专栏的第三部分中详细讲解，这里就暂不展开。 二、CPU、操作系统、虚拟机 上面反复提到了 CPU、操作系统、虚拟机，现在，我们就来看下，它们在程序的执行过程中，扮演了什么角色。CPU 的工作非常明确，用来执行编译好的机器指令，我们重点看下操作系统和虚拟机。 1）操作系统在程序执行中的作用 早期的计算机还没有高级语言和操作系统，程序员用机器指令编写的代码，通过纸带打卡方式记录下来，传输给计算机（可以理解为 CPU）直接执行。 随着硬件资源越来越丰富，计算机中开始集成各种硬件设备，比如内存、硬盘、各种输入输出（键盘、鼠标、显示器等），并且，人们希望多个程序能在计算机中并发执行（比如听歌的同时还能打字），于是，操作系统就诞生了。 操作系统用来管理硬件资源和调度程序的执行。打个比方，CPU 等硬件就好比车间中的机器，工人就像操作系统，一个个程序就像一个个待执行的任务。工人（操作系统）调度机器（CPU 等硬件）来执行各个任务（程序）。 除此之外，操作系统还担当了类库的作用 。对于通用的功能代码，比如读写硬盘等，没必要在每个程序中都从零编写一遍。 操作系统将这些通用的功能代码，封装成 API（专业名称叫做系统调用），供我们在编写应用程序时直接调用。也就是说，在应用程序的执行过程中，CPU 可能会跳转去执行操作系统中的某段代码。当然，这段代码肯定是已经编译好的机器指令。 2）虚拟机在程序执行中的作用 我们先下来对比一下，C++ 代码、Python 代码、Java 代码编译和执行的命令。如下所示。 12345678910// C++ $ g++ helloword.cpp -o helloworld $ ./helloword // Python $ python helloworld.py // Java $ javac HelloWorld.java $ java HelloWorld 仔细观察上述命令行的区别，我们可以看出，C++ 编译之后的代码直接就可以执行，而 Python 和 Java 代码的执行，需要依赖其他程序，也就是虚拟机，表现在命令行中就是前面有 python、java 字样。 使用解释型和混合型语言编写的代码，执行过程都需要虚拟机的参与。实际上，虚拟机本身也可以看做一个程序，而且它已经是 CPU 可以执行的机器指令了。程序员编写的代码相当于嵌套在虚拟机程序中一个插件（或者功能模块），只不过，它跟虚拟机本身的代码有点不同，无法直接交给 CPU 执行。虚拟机将字节码翻译成 CPU 指令，放到固定的内存位置，再通过修改 CPU 寄存器中存储的地址的方式，引导 CPU 执行这块内存中存储的 CPU 指令（关于这一部分，我们待会会详细讲解）。 如果你是一名经验丰富的 Java 工程师，不知道你有没有感觉到，虚拟机的这套解释执行的机制，跟 Java 的反射语法异曲同工，反射是在代码的执行过程中，将字符串（类名、方法名等）转化成代码之后再被执行。而虚拟机的解释执行是将字节码（也可以看做是字符串）转化成 CPU 指令再执行。 三、CPU 指令、汇编语言、字节码 前面反复提到 CPU 指令、字节码，估计你对此会很好奇，它们到底长什么样子。现在，我们就来具体看下。不过，提到 CPU 指令，免不了要讲一下汇编语言，所以，接下来，我们也会一并讲一下汇编语言。站在操作系统和 CPU 的角度，Java 程序编译之后的字节码跟虚拟机合并在一起，才算是一个完整的程序，才相当于 C++ 编译之后的可执行文件。CPU 在执行程序员编写的代码的同时，也在执行虚拟机代码。而且是先执行虚拟机代码，然后才是引导执行程序员编写的代码。 1 ）CPU 指令 前面提到，我们经常说的 CPU 指令、机器码、机器指令，实际上都是一个东西，就是 CPU 可以完成的操作。一条 CPU 指令包含的信息主要有：操作码、地址、数据三种，指明所要执行的操作、数据来源、操作结果去向。 cpu 可以完成的所有的操作，叫做指令集。常见的指令集有 X86、X86-64、ARM、MIPS 等。不同的 CPU 支持的指令集可能不同（Intel CPU 支持的 X86 指令集，ARM CPU 支持指令集 ARM）。当然，不同的 CPU 支持的指令集也可以相同（比如 Intel 和 AMD 的 CPU 都支持 X86 和 X86-64 指令集）。同一个 CPU 也可以支持多种指令集（Intel CPU 支持的指令集有 X86、X86-64 以及其他扩展指令集）。CPU 支持的指令集一般都非常庞大，例如 Intel CPU 支持 2000 多条指令，可以完成诸多不同类型的操作。 2）汇编语言 前面提到，在计算机发展的早期，程序员直接使用机器码来编写程序。但是，因为机器码是二进制码，所以，编写起来复杂、可读性也不好。为了解决这个问题，汇编语言就被发明出来了。汇编语言由一组汇编指令构成 ，汇编指令跟 CPU 指令一一对应， 但汇编指令采用字符串而非二进制数来表示指令，所以，可读性好很多。实际上，CPU 指令和汇编指令之间的关系，就类似 IP 地址和域名之间的关系，IP 地址和域名一一对应，域名的可读性比 IP 地址好。 程序员使用汇编语言编写的代码，需要经过编译，翻译成机器码才能被 CPU 执行。这个编译过程有个特殊的名称，叫做“汇编”。C/C语言的编译过程，实际上就包含汇编这一步骤。编译器先将 C/C代码编译成汇编代码，然后再汇编成机器码。 我们拿一段 C 语言代码来举例，如下所示，看看编译之后的汇编代码长什么样子。 12345678// hello.c#include &lt;studio.h&gt;int main()&#123; int a = 1; int b = 2; int c = a + b; return c;&#125; 上述代码编译为汇编代码，如下所示： 12345678910111213141516171819$ gcc -S hello.c $ cat hello.s _main: ## @main .cfi_startproc ## %bb.0: pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset %rbp, -16 movq %rsp, %rbp .cfi_def_cfa_register %rbp movl $0, -4(%rbp) movl $1, -8(%rbp) movl $2, -12(%rbp) movl -8(%rbp), %eax addl -12(%rbp), %eax movl %eax, -16(%rbp) movl -16(%rbp), %eax popq %rbp retq 有同学可能有疑问，这个汇编代码跟他见过的不大一样，实际上，汇编指令跟 CPU 指令一一对应，相同指令集对应的汇编指令集都是一样的（比如上面的代码是 Intel 的 CPU 支持的 X86 指令集对应的汇编代码），只不过语法格式有可能不同。汇编语言主要有两种语法格式，一种是 Intel 风格的，一种是 AT&amp;T 风格的。上述汇编代码是 AT&amp;T 风格，对应的 Intel 风格如下所示。对比上下两段汇编代码，唯一的区别就是格式不同而已。注意下面这段代码添加了部分注释，汇编中的注释以分号开头。 12345678910111213141516171819202122$ gcc -S -masm=intel hello.c $ cat hello.s _main: ## @main .cfi_startproc ## %bb.0: push rbp .cfi_def_cfa_offset 16 .cfi_offset rbp, -16 mov rbp, rsp .cfi_def_cfa_register rbp mov dword ptr [rbp - 4], 0 ; 安全 word，没有实际意义 mov dword ptr [rbp - 8], 1 ;int a = 1; 存储在栈中 rbp-8 的位置 mov dword ptr [rbp - 12], 2 ;int b = 2; 存储在栈中 rpb-12 的位置 mov eax, dword ptr [rbp - 8] ;a 的值累加在寄存器 eax 上 add eax, dword ptr [rbp - 12] ;b 的值累加在寄存器 eax 上 mov dword ptr [rbp - 16], eax ;int c = a+b mov eax, dword ptr [rbp - 16] ;return c。返回值通过 eax 返回给上层。 ; 所以，把 c 值赋值给 eax。因为上一句指令结束之后， ; 有可能还有其他运算还会用到 eax（本程序比较简单，没有其他运算了）， ; 所以 eax 中的值有可能会被改变，所以程序返回时重新将 c 值重新赋值给 eax。 pop rbp ret 对于没学习过汇编语言的同学，完全理解上述汇编代码可能比较困难。不过，这里，我们只需要简单了解汇编代码长什么样子，有个直观的认识即可。关于以上汇编代码的具体解释，我们在下一节会讲到。 3）字节码 我们常说，Java 语言是跨平台的，“write once, run anywhere”（一次编写，多处运行）。程序员编写的代码，在不需要任何修改的情况下，就可以运行在不同的平台上（不同的操作系统和 CPU）。 有人认为，Java 语言之所以能跨平台，是字节码的功劳。因为字节码跟平台无关，我们在一个平台上编译得到的字节码，可以运行在其他平台上。 实际上，这样的观点是不确切的。毕竟没有字节码的解释型语言也可以跨平台。字节码诞生的目的是，克服解释型语言解释执行速度慢的缺点（字节码是介于高级语言和机器码之间的形态，比高级语言解释执行更快）。字节码跟平台无关，是为了让 Java 语言保留解释型语言跨平台的优点，而不是促使 Java 语言跨平台的最根本原因。这一点要搞清楚。 之所以 Java 语言能做到跨平台，最根本原因是有虚拟机的存在。Java 代码跟平台无关，字节码跟平台无关，在编译执行过程中，总要有一个环节跟平台有关，不然，跟平台有关的、最终可以被 CPU 执行的机器码从何而来。俗话说的好，哪有什么岁月静好，只是有人帮你负重前行。跟平台有关的环节就是解释执行环节，而这个环节的主导者就是虚拟机。 虚拟机是已经编译好的可以被 CPU 执行的机器码，而机器码又是跟平台有关的，因此虚拟机必须跟平台有关。这也是为什么在不同的平台（操作系统和 CPU）上，我们需要下载不同的 Java 虚拟机的原因。 明确了字节码的作用之后，我们通过一个简单的例子，来看下字节码到底长什么样子？ 1234567public class HelloWorld &#123; public static void main (String[] args) &#123; int a = 1; int b = 222222; int c = a + b; &#125; &#125; 对于上面的代码，我们使用 javac 命令编译之后，会得到一个后缀为.class 的文件 HelloWorld.class，这个文件里保存的一堆二进制码就是字节码。为了方便查看，我们用 vi 打开转化成 16 进制格式之后，如下所示： 显然，这样的二进制文件是交给虚拟机解析的，人类阅读起来非常费劲。我们可以 使用 javap 工具，将 class 文件解析成适合人类阅读的格式，如下所示。这个过程被叫做反编译。为啥叫做反编译呢？我们可以跟“编译”对比着理解。编译是将贴近人阅读的内容，翻译成贴近机器阅读的内容的过程。对应地，反编译就是将贴近机器阅读的内容，翻译成贴近人阅读的内容的过程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859$ javap -verbose HelloWorld Classfile /Users/wangzheng/Desktop/HelloWorld.class Last modified 2022-3-20; size 291 bytes MD5 checksum ea48b76348ad4f0c07a2bf96840e8e00 Compiled from &quot;HelloWorld.java&quot; public class HelloWorld minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPER Constant pool: #1 = Methodref #4.#13 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Integer 222222 #3 = Class #14 // HelloWorld #4 = Class #15 // java/lang/Object #5 = Utf8 &lt;init&gt; #6 = Utf8 ()V #7 = Utf8 Code #8 = Utf8 LineNumberTable #9 = Utf8 main #10 = Utf8 ([Ljava/lang/String;)V #11 = Utf8 SourceFile #12 = Utf8 HelloWorld.java #13 = NameAndType #5:#6 // &quot;&lt;init&gt;&quot;:()V #14 = Utf8 HelloWorld #15 = Utf8 java/lang/Object &#123; public HelloWorld(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 1: 0 public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=4, args_size=1 0: iconst_1 1: istore_1 2: ldc #2 // int 222222 4: istore_2 5: iload_1 6: iload_2 7: iadd 8: istore_3 9: return LineNumberTable: line 3: 0 line 4: 2 line 5: 5 line 6: 9 &#125; SourceFile: &quot;HelloWorld.java&quot; 不过，你有没有产生过这样的好奇，class 文件为什么叫字节码？跟字节（byte）有什么关系呢？实际上，class 文件里包含了很多类的信息，而其中 main()函数中的代码对应的字节码指令（字节码指令是二进制的，下面的是反编译之后的助记符）只有下面这几行： 1234567890: iconst_1 // 把 int 型 1 入栈 1: istore_1 // 把栈顶 int 型数值存入第一个变量，也就是 a 2: ldc #2 // 将常量池中的 #2 号常量 222222 入栈 4: istore_2 // 把栈顶 int 型数值存入第二个变量，也就是 b 5: iload_1 // 把第一个变量的值入栈 6: iload_2 // 把第二个变量的值入栈 7: iadd // 将栈顶的两个 int 型数据相加，结果压入栈 8: istore_3 // 将栈顶 int 型数值存入第三个变量，也就是 c 9: return // 程序返回 一条字节码指令有些包含操作码和操作数两部分，有些只包含操作码这一部分。因为操作码长度为一个字节，所以，这种指令格式被叫做字节码。从另一个角度，我们也可以得知，字节码的操作码类型不超过 256 个（2^8）。相对于 CPU 指令和汇编指令，字节码指令少很多。这是因为字节码指令相对于 CPU 指令来说，抽象程度更高。一条字节码指令完成的逻辑，比一条 CPU 指令完成的逻辑，更加复杂。 Java8 的字节码指令集 点击此处 查看 四、代码是如何被 Cpu 执行的 有了以上铺垫，我们最后讲解一下：“代码是如何被 CPU 执行的”。 不管是使用哪种类型的编程语言（编译型、解释型、混合型）编写的代码，不管经历什么样的编译、解释过程，最终交给 CPU 执行的都是机器码。 提到 CPU，就不得不提寄存器。 我们知道，内存的读写速度比起 CPU 指令的执行速度要慢很多。从内存中读取 32 位二进制数据所耗费的时间，相当于 CPU 执行上百条指令所耗费的时间。所以，CPU 在执行指令时，如果依赖内存来存储计算过程中的中间数据，那么，CPU 总是在等待读写内存操作的完成，势必非常会影响 CPU 的计算速度。为了解决这个问题，寄存器就被发明出来了。 寄存器读写速度非常快，能够跟 CPU 指令执行速度相匹配。所以，数据会先读取到寄存器中再参与计算。不过，你可能会说了，数据在计算前需要先从内存读取到寄存器，计算之后存储在寄存器中的结果也要写入到内存，寄存器的存在并没有避免掉内存的读写，使用寄存器是不是多此一举呢？实 际上，尽管最初数据来源于内存，最后计算结果也要写入内存，但中间的计算过程涉及到一些临时结果的存取，都可以在寄存器中完成，不用跟非常慢速的内存进行交互。顺便说一句，计算机为了提高 CPU 读写内存的速度，还引入了 L1、L2、L3 这三级缓存。 寄存器为了做到能让 CPU 高速访问，硬件设计比较特殊（高成本、高能耗），且与 CPU 距离很近（相对于内存来说，寄存器直接跟 CPU 集成在一起），这些也决定了寄存器的个数不会很多。不同的 CPU 包含的寄存器会有所不同。常见的寄存器有以下几类。 1）通用寄存器：AX，BX，CX，DX 通用寄存器区别于下面要讲到的特殊寄存器，它们一般用来存储普通数据。AX，BX，CX，DX 这四种通用寄存器的用途又有所区别，比如 AX 是累加器，这些细节我们就不展开讲解了。 2）指针寄存器：BP，SP，SI，DI，IP BP（Base Pointer Register）和 SP（Stack Pointer Register）是用于存储栈空间地址的寄存器，SP 存储栈顶地址，BP 比较特殊，一般存储栈中一个栈帧的栈底地址。这一部分在下一节讲解函数的执行过程时再详细讲解。 SI（Source Index Register）源地址寄存器和 DI（Destination Index Register）目的地址寄存器，分别用来存储读取和写入数据的内存地址。 IP（Instruction Pointer Register）指令指针寄存器存储下一条将要执行的指令的内存地址（此处的描述不够准确，下文解释）。 3）段寄存器：CS，DS，SS 程序由一组指令和一堆数据组成。指令存储在某块内存中（这块内存被称为代码段），由 CPU 逐一读取执行。数据也存储在某块内存中（这块内存被称为数据段）。指令执行的过程中，会操作（读取或写入）这块内存中的数据。 CS（Code Segment Register）代码段地址寄存器存储了代码段的起始地址。上文中讲到，IP 寄存器中存储的是下一条将要执行的指令的内存地址，实际上，这样的说法是不准确的。CS 和 IP 两个寄存器中存储的内容如下计算，才能得到一个真正的物理内存地址。 1物理内存地址 = 段地址（如 CS） * 16 + 偏移地址（如 IP） 我们拿 8086 CPU（早期 16 位的 X86 CPU）举例解释。8086 CPU 具有 20 位地址总线，支持 1MB 内存的寻址能力。对于 16 位的 IP 寄存器，只能存储 64K（2^16）个内存地址，一个字节占一个地址，那么只能支持 64KB 大小内存的寻址。为了扩大寻址能力，计算机使用段地址和偏移地址相结合的方式来确定一个物理内存地址。 对于存储下一条将要执行的指令的地址的寄存器，你或许还听到过 PC 寄存器（Program Counter Register）这种叫法。实际上，PC 寄存器是一个抽象概念，CS 寄存器和 IP 寄存器是具体寄存器的名称。我们可以简单理解为 PC 寄存器就是 CS 寄存器和 IP 寄存器的抽象统称。 DS（Data Segment Register）数据段地址寄存器存储了数据段的起始地址，同理，它跟 DI 或 SI 结合才能确定一个数据段中的内存地址。 SS（Stack Segment Register）栈寄存器存储的是栈的起始地址，同理，它跟 SP 结合才能确定栈顶的内存地址，跟 BP 结合才能确定栈中某个中间位置的内存地址。有些同学看到这里可能会有疑问，数据段是存储数据的，栈也是存储数据，这两者有什么联系呢？关于这个问题，我们在下一节文章中会讲到。 4）指令寄存器：IR IR（Instruction Register）指令寄存器用来存放当前正在执行的指令。指令为一串二进制码，指令译码器需要从指令中解析出操作码和操作地址或操作数。所以，指令需要暂存在指令寄存器中等待译码处理。 5）标志寄存器 FR（Flag Register）标志寄存器，也叫做程序状态字寄存器（Program Status Word，PSW）, 在这个寄存器中的每一个二进制位记录一类状态。比如 cmp 比较大小指令的运算结果会存储在 ZF 零标志位或 CF 进位标志位中。关于更多细节，我们不展开讲解。 以上寄存器都是用来辅助完成 CPU 的各种指令。注意，以上是 16 位的寄存器，32 位的寄存器名称在对应的 16 位寄存器名称前加 E（例如 EAX，EBP，ESP，EIP），64 位的寄存器名称在对应的 16 位寄存器名称前加 R（例如 RAX，RBP，RSP，RIP）。在下一节中，在讲解编程语言基本语法的底层实现原理时，我们还会提到更多寄存器的使用细节。 了解了 CPU 指令执行的重要部件寄存器之后，我们来看下 CPU 执行指令的流程。 对于编译型语言，操作系统会把编译好的机器码，加载到内存中的代码段，将代码中变量等数据放入内存中的数据段，并且设置好各个寄存器的初始值，如 DS、CS 等。IP 寄存器中存储代码段中第一条指令的内存地址相对于 CS 的偏移地址。 CPU 根据 PC 寄存器（CS 寄存器和 IP 寄存器的总称）存储的内存地址，从对应的内存单元中取出一条 CPU 指令，放到 IR 指令寄存器中，然后将 IP 寄存器中的地址 +4（也就是下一条指令在代码段中的偏移地址。内存中的每一个字节都对应一个地址。对于 32 位 CPU，一条指令长度为 4 字节，下一条指令地址 = 当前指令地址 +4。对于 64 位 CPU，一条指令长度是 8 字节，下一条指令地址 = 当前指令地址 +8）。一条指令执行完成之后，再通过 PC 寄存器中的地址，取下一条指令继续执行。循环往复，直到所有的指令都执行完成。 对于解释型或混合型语言，操作系统将虚拟机本身的机器码，加载到内存中的代码段，然后一条一条地被 CPU 执行。这部分被执行的指令对应的功能，就包括把程序员编写的程序解释成机器码这一功能。虚拟机把解释好的机器码会放到某段内存中，然后将 PC 寄存器的地址设置为这段内存的首地址，于是，CPU 就被虚拟机引导去执行程序员编写的代码了。 在本节中，我们把程序用到的内存，粗略地分为代码段和数据段，对于 Java 语言来说，其虚拟机对内存还做了更加细致的划分，这部分内容我们在专栏的 JVM 部分讲解。 五、课后思考题 1）在你熟悉的语言中，有哪些是解释型语言？哪些是编译型语言？哪些是混合型语言？ 2）本节中提到，C/C代码会先编译成汇编代码，再汇编成机器码，才能被执行。按理来说，汇编代码跟机器码一一对应，为什么 C/C代码不直接编译成机器码呢？先编译成汇编代码不是多此一举吗？ # 未理解 ： 寄存器的各种形式","categories":[{"name":"编程艺术","slug":"编程艺术","permalink":"https://wenjing-xin.github.io/categories/%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/"}],"tags":[{"name":"CS","slug":"CS","permalink":"https://wenjing-xin.github.io/tags/CS/"}],"author":"dreamChaser"},{"title":"如何编写 Restful 风格的接口","slug":"RESTFUL风格的接口","date":"2023-03-12T01:14:00.000Z","updated":"2024-02-16T07:27:56.232Z","comments":true,"path":"posts/48662/","link":"","permalink":"https://wenjing-xin.github.io/posts/48662/","excerpt":"","text":"一、Restful 风格接口 Restful 风格的 API 是一种软件架构风格，设计风格而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。 在 Restful 风格中，用同一个请求接口（URL）而用不同的请求方式，这就避免了编写多个不同的 URL，通过请求的方式也更容易区分出每个方法的功能。 客户端使用 GET、POST、PUT、DELETE 4 个表示操作方式的动词对服务端资源进行操作： GET 用来获取资源， POST 用来新建资源（也可以用于更新资源）， PUT 用来更新资源， DELETE 用来删除资源 二、RESTful 风格接口注意事项： 2.1、RESTful 接口 URL 命名原则 命名原则 1：HTTP 方法后跟的 URL 必须是名词且统一成名词复数形式 命名原则 2：URL 中不采用大小写混合的驼峰命名，尽量采用全小写单词，如果需要连接多个单词，则采用〞-”连接 示例：/users、 /users-fans；反例：/getUsers、 /getUsersFans 2.2、RESTful 接口 URL 分级原则 分级原则 1：一级用来定位资源分类，如 /users 即表示需要定位到用户相关资源 分级原则 2：二级仍用来定位具体某个资源，如 /users/20 即表示 id 为 20 的用户，再如 /users/20/fans/1 即表示 id 为 20 的用户的 id 为 1 的粉丝 一条小建议：原则是为了让我们的开发更加规范，但是不能成为束缚我们开发的枷锁！ 2.3、复杂 get 请求接口命名示例： 三、接口的编写 3.1、get 方式的请求参数详解： 参数拼接与路径中 后端接口 1234@GetMapping(&quot;/hello/&#123;name&#125;&quot;)public String hello(@PathVariable(&quot;name&quot;) String name) &#123; return &quot; 获取到的 name 是：&quot; + name;&#125; 请求地址 1localhost:8080/hello/tom 以键值对形式拼接于路径中 后端接口 1234@GetMapping(&quot;/hello&quot;)public String hello(String name) &#123; return &quot; 获取到的 name 是：&quot; + name;&#125; 请求路径 1localhost:8080/hello?name=tom 注意：多个参数之间使用 &amp; 连接 自定义参数名称： 用于拼接在路径后边的参数名称和接收名称不一致的时候使用 后端接口 1234@GetMapping(&quot;/hello&quot;)public String hello(@RequestParam(&quot;namename&quot;) String name) &#123; return &quot; 获取到的 name 是：&quot; + name;&#125; 请求路径 1localhost:8080/hello?namename=tom 可缺省参数 后端接口 1234@GetMapping(&quot;/hello&quot;)public String hello(@RequestParam(required = false) String name) &#123; return &quot; 获取到的 name 是：&quot; + name;&#125; 默认值参数 后端接口 12345@GetMapping(&quot;/hello&quot;)public String hello(@RequestParam(defaultValue = &quot;unnamed&quot;) String name) &#123; return &quot; 获取到的 name 是：&quot; + name;&#125; 请求地址 1localhost:8080/hello 使用 map 接收参数 后端接口 1234@GetMapping(&quot;/hello&quot;)public String hello(@RequestParam Map&lt;String, Object&gt; params) &#123; return &quot;name：&quot; + params.get(&quot;name&quot;) + &quot;，age：&quot; + params.get(&quot;age&quot;);&#125; 请求地址 1localhost:8080/hello?name=tom&amp;age=18 使用对象接收参数 后端接口 1234@GetMapping(&quot;/hello&quot;)public String hello(User user) &#123; return &quot;name：&quot; + user.getName() + &quot;，age：&quot; + user.getAge();&#125; 请求地址 1localhost:8080/hello?name=tom&amp;age=jerry 其中，name 和 age 是实体对应的属性，必须要保证其一致性，才能接收到参数。 3.2、post 方式 123456// 用户注册 @PostMapping(&quot;/reg&quot;) public R register(@RequestBody User user)&#123; return userService.insert(user); &#125; put 方式 1234567// 用户更新 @PutMappingpublic R&lt;?&gt; modify(@RequestBody User user)&#123; return userService.update(user);&#125; delete 方式 12345// 删除用户 @DeleteMapping(&quot;/&#123;id&#125;&quot;)public R&lt;?&gt; remove(@PathVariable Long id)&#123; return userService.delete(id);&#125;","categories":[{"name":"编程艺术","slug":"编程艺术","permalink":"https://wenjing-xin.github.io/categories/%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/"}],"tags":[{"name":"接口风格","slug":"接口风格","permalink":"https://wenjing-xin.github.io/tags/%E6%8E%A5%E5%8F%A3%E9%A3%8E%E6%A0%BC/"},{"name":"Restful","slug":"Restful","permalink":"https://wenjing-xin.github.io/tags/Restful/"}],"author":"稳静逐梦"},{"title":"分布式版本控制工具 git 的基本使用","slug":"分布式版本控制工具-git-的基本使用","date":"2022-09-11T04:15:00.000Z","updated":"2024-02-16T07:27:56.235Z","comments":true,"path":"posts/35886/","link":"","permalink":"https://wenjing-xin.github.io/posts/35886/","excerpt":"","text":"一、介绍 1.1 、为什么要学习版本控制 一个完整的项目从需求调研——&gt; 系统上线。中间有个环节叫开发，开发是多人合作开发，那么就存在以下问题: 将每个人开发的功能代码合并到一起 代码回退到指定的版本 查看每个人提交的日志记录 管理员要删除某个分支的某个阶段的代码 备份每个人的代码 1.2 、版本控制方式 集中式的版本控制 客户端：每个开发人员服务端：每个人开发的程序都存放在服务端，如果团队成员需要从服务端拉取最新的代码，需要联网下载，如果服务端无法正常运行了，就存在整个程序丢失的情况。版本控制工具：Svn、Cvs 分布式的版本控制工具 本地仓库: 每个开发人员 远程仓库: 和本地仓库类似，团队中的每个人都有一套和远程仓库 一样 的代码，就算数据丢失，那也可以依靠团队找回回来，不存在单点故障问题。版本控制工具:git 1.3、git 版本控制工具的原理： 1、克隆(clone): 将远程仓库代码下载到本地仓库。 2、检出(checkout): 从本地仓库创建一个分支。 3、添加(add): 将工作区的代码保存到暂存区。 4、提交(commit): 将暂存区的代码提交到本地仓库。 5、拉取(pull): 将远程仓库的代码拉取到本地仓库并自动合并代码。 6、抓取(fetch): 将远程仓库的代码拉取到本地仓库。 7、推送(push): 将本地仓库代码推送到远程仓库。 本地仓库: 每个人自己电脑上的项目目录; 远程仓库: 与他人实现代码共享的库; 工作区: 开发代码的区; 暂存区: 就是将工作区的代码提交到的目标地址; Git 是一个分布式版本控制系统，它用于跟踪项目文件的更改，并允许多人协作。Git 的主要原理包括： 快照：Git 不像其他版本控制系统那样存储文件的差异，而是将每个提交（commit）视为项目文件的完整快照。每次提交更改时，Git 都会将所有文件的快照存储在一个本地仓库（repository）中。 分布式架构：每个开发人员在本地计算机上都有完整的项目历史，这意味着在进行更改、创建分支（branch）和提交时，不需要与远程服务器通信。这使得 Git 速度很快，同时还提高了安全性。 分支与合并：Git 的分支功能使得开发人员能够在独立的分支上进行开发，而不会影响主分支（通常称为“master”或“main”分支）。在完成开发后，可以通过合并（merge）操作将分支的更改合并回主分支。 一致性与完整性：Git 使用 SHA-1 哈希算法为每个提交生成一个唯一的校验和。这意味着每次提交都有一个唯一的表示，可以确保项目历史的一致性和完整性。 压缩存储：虽然 Git 存储的是文件的完整快照，但它采用了压缩和存储优化技术来减少所需的存储空间。Git 只存储每个文件的不同版本，并对相似的文件进行压缩。 操作类型：Git 的基本操作包括初始化（init）、克隆（clone）、添加（add）、提交（commit）、拉取（pull）、推送（push）、分支（branch）、检出（checkout）和合并（merge）等。这些操作使得开发人员能够轻松地在项目上进行合作。 总之，Git 版本控制的原理是通过跟踪项目文件的快照、分布式架构、分支与合并等功能来支持开发人员进行协同工作。同时，Git 还确保了项目历史的一致性、完整性和存储效率。 二、安装与配置 ✅ 下载地址 双击可执行文件后，持续下一步，直到安装成功。 ✅ 如何验证是否安装成功：在你电脑的终端上直接输入以下指令回车。 1git --version 当终端出现你的 git 版本信息的时候就证明 git 已经安装成功了。 1git version 2.29.2.windows.2 mac m1 上建议使用 home brew 进行安装。 三、基本配置 ✅ 设置 git 用户信息 12345git config --global user.name &quot;cxsw&quot;git config --global user.email &quot;cxsw@126.com&quot;git config --global core.editor &quot; 编辑器名称 &quot;git config --global init.defaultBranch &quot; 分支名称 &quot;git config --list 检查配置信息 ✅ 查询信息 12git config --global user.namegit config --global user.email ✅ 使用 git 时经常遇到的一些 Linux 命令 12345678ls/ll # 查看当前目录，ll 是可以查看隐藏的文件夹ls -al # 查看所有文件(包含隐藏文件及文件夹)cat # 查看文件的内容touch # 创建文件vi # 在 vi 编辑器中打开当前文件mkdir 目录名称 # 在当前路径下创建一个目录rmdir 目录名称 # 在当前路径下移除指定的目录clear # 清空当前屏幕 退出 vi 文件编辑器的操作：首先按下 ESC ，然后输入 :wq 即可。 四、本地仓库操作 4.1、基本操作 查看最新版本提交 1git log -1 初始化本地仓库 1git init # 执行此命令后会在当前目录出现一个 .git 的目录 查看修改的状态（暂存区和工作区） 1git status 添加修改的文件至暂存区 12345678git add # 不加参数时默认将修改的文件和未跟踪的新增文件添加到暂存区，但是不包括删除的文件git add * # 添加所有文件至暂存区，不会根据 .gitignore 做忽略git add . # 添加所有文件至暂存区，会根据 .gitingore 文件做一个忽略git add -u . # -u 表示将已跟踪文件中的修改和删除的文件添加到暂存区，** 不包括新增加的文件 **，注意这些被删除的文件被加入到暂存区再被提交并推送到服务器的版本库之后这个文件就会从 git 系统中消失了。git add -A . # -A 表示将已跟踪文件中的修改和删除的文件添加咱暂存区，包括新增的文件。git add *.html # 添加某种类型的文件到暂存区git add index/ # 添加该目录下的所有文件git add index/Test.java # 添加相对于当前目录下的某个指定文件 提交代码至本地仓库 1git commit -m &#x27; 对本地提交代码的简要说明 &#x27; 查看日志 123git log # 查看当前分支的日志git log --all # 查看所有分支的日志git reflog # 查看详细日志，它保存了本地仓库初始化后的所有详细操作 版本回退 1234git reset --hard commitId # 将本地仓库的文件回退到工作区 ** 不留痕迹的回退，谨慎使用 **git reset &quot;HEAD^&quot; # 将本地仓库回退到工作区git reset HEAD 文件名 # 将暂存区代码回退到工作区git reset 文件名 # 将暂存区代码回退到工作区 忽略文件的配置 创建 .gitingore 文件 123456# 忽略指定类型的文件*.txt. # 忽略指定目录下的文件dist/# 忽略某个目录下指定的文件build/*.txt 根据实际情况灵活配置。 4.2、分支操作 ✅ 分支适用于多人协作开发，每个人都可以拥有一个分支，要保证每个分支的名字不重复。 查看分支 1git branch 在本地创建分支 1git branch 分支名称 切换分支 1git checkout 分支名 合并分支 1git merge 分支名称 切换到一个不存在的分支并创建它 1git checkout -b 分支名 删除分支 12git branch -d 分支名称 # 删除分支时需要做各种检查git branch -D 分支名称 # 删除分支时不需要组任何检查，强制删除 解决冲突 当两个分支上对同一个文件修改时就会产生冲突，例如同时修改了同一个文件的同一行，解决冲突的步骤如下： 处理文件中出现冲突的地方 将解决完冲突的文件加入到暂存区 提交到仓库 4.3、开发中分支的使用原则与流程 实际开发中，一般有如下分支使用原则与流程： master （生产） 分支 线上分支，主分支，中小规模项目 作为线上运行的应用对应的分支； develop（开发）分支 是从 master 创建的分支，一般作为 开发部门的主要开发分支 ，如果 没有其他并行开发不同期上线 要求，都可以在此版本进行开发，阶段开发完成后，需要是合并到 master 分支, 准备上线。 feature/xxxx 分支 从 develop 创建的分支，一般是同期并行开发，但不同期上线时创建的分支，分支上的研发任务完成后合并到 develop 分支。 hotfix/xxxx 分支 从 master 派生的分支，一般作为线上 bug 修复使用，修复完成后需要合并到 master、test、 develop 分支。 还有一些其他分支，在此不再详述，例如 test 分支（用于代码测试）、pre 分支（预上线分支）等 等。 五、远程仓库操作 5.1、常见的远程仓库操作服务器 常见的代码托管服务器 GitHub：由于服务器在国外，国内很多时候不使用。 Gitee：国内比较出色的代码托管服务平台 Gitlab：需要通过自己搭建的代码托管服务平台，企业使用的比较多 5.2、配置 SSH 公钥（windows） ✅ 生成 SSH 公钥 ssh-keygen -t rsa 不断回车 如果公钥存在，则自动覆盖 ✅ Gitee 设置账户公钥（生成的密钥是保存在你当前用户文件下的 .ssh 文件里边） cat ~/.ssh/id_rsa.pub ✅ 验证配置是否成功 ssh -T git@gitee.com ✅ 如果出现以下提示则代表成功 1Hi webj! You&#x27;ve successfully authenticated, but GITEE.COM does not provide shell access. 5.3、常用操作 远程克隆代码到本地仓库或者工作区 1git clone 项目地址 # 项目地址可以用 ssh 地址，也可以用 Https 地址 查看远程仓库地址 1git remote -v # 注意你查看地址时，** 确保当前地址在 git 仓库中，否则会提示不是 git 仓库（或者任何父目录）** 将本地仓库和远程仓库进行关联 12# origin 远程仓库名称。一般默认的仓库名称都是 origin ，如果你远程的仓库修改了，添加对应的名称即可git remote add origin 远程仓库地址 将本地仓库代码推送到远程仓库 ✅ git push [-f] [–set-upstream] [远端名称 [ 本地分支名] [: 远端分支名] ] 12345678# 该命令将本地的 master 分支推送到 origin 主机，同时指定 origin 为默认主机，后面就可以不加任何参数使用 git push 了。git push -u origin master # 已经指定了主机时采用该命令将本地的 master 分支推送到远程仓库git push # 推送到远端的同时并且建立起和远端分支的关联关系git push --set-upstream origin master# 强制覆盖git push -f origin master 拉取命令 ✅ git fetch [remote name] [branch name] 12git fetch origin master # 抓取指令就是将仓库里的更新都抓取到本地，不会进行合并。git fetch # 如果不指定远端名称和分支名，则抓取所有分支。 抓取远程仓库代码至本地仓库 ✅ git pull [remote name] [branch name] 12git pull origin dev # 抓取远程仓库的 dev 分支拉取到本地并自动进行合并git pull # 如果不指定远端名称和分支名称，则抓取所有并更新当前分支 该命令等同于 fetch + merge 解决合并冲突 当执行 git pull origin [分支名] 时，如果同一个文件的远程分支和本地分支代码不一致，那么就参数冲突，这个时候就需要手动处理，处理步骤: 1、处理冲突 2、将处理完成的代码保存到暂存区 3、将暂存区的代码提交到本地仓库 4、将本地仓库代码提交到远程仓库 📖 关于 git 的指令操作到此全部记录完毕，关于 git 在 VS code、idea 中的集成使用后续会继续记录。但是个人认为，如果是从事这个职业的人员，熟练指令操作是最基本的，不能舍本逐末，直接上手可视化的集成操作。","categories":[{"name":"工具集合","slug":"工具集合","permalink":"https://wenjing-xin.github.io/categories/%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/"}],"tags":[{"name":"git","slug":"git","permalink":"https://wenjing-xin.github.io/tags/git/"},{"name":"版本控制","slug":"版本控制","permalink":"https://wenjing-xin.github.io/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"}],"author":"稳静逐梦"},{"title":"如何搭建前后端分离的项目","slug":"如何搭建前后端分离的项目","date":"2022-08-30T09:47:00.000Z","updated":"2024-02-16T07:27:56.237Z","comments":true,"path":"posts/28787/","link":"","permalink":"https://wenjing-xin.github.io/posts/28787/","excerpt":"","text":"前后端分离已经成为现今的主流开发模式，本篇将通过 demo 报道登记管理系统介绍如何搭建一个前后端分离的 web 应用。 1、报道登记管理系统介绍 后台技术栈： spring + spring mvc + mybatis + mysql8.0 前台技术： vue + vuex + element-ui 主要功能介绍 1、用户登录(包括自动登录)、退出、权限拦截 2、学生报道登记管理（列表、新增、编辑、删除、按条件查询、文件上传） 2、页面展示 管理员的主页显示 填报界面 用户管理界面 3、前后端项目结构 目录及构图 后端目录结构图： 前端目录结构图 前后端分离搭建项目时的要点： 前端 前端还是使用较为经典的 vue2 项目，通过 vue-cli 搭建。 后端 搭建时，注意还是搭建 maven 的 web 项目，这样才能建立后端服务，也尝试搭建过 maven 的普通 Java 项目，但是后边发现把它放在 tomcat 服务器里边无法为前端提供服务。 4、解决前后端分离时的跨域问题 4.1、为什么会产生跨域问题 跨域问题是因为浏览器的同源策略引起的，所谓同源是指 &quot; 协议 + 域名 + 端口 &quot; 三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源。同源策略 /SOP（Same origin policy）是一种约定，由 Netscape 公司 1995 年引入浏览器，它是浏览器最核心也最基本的安全功能，现在所有支持 JavaScript 的浏览器都会使用这个策略。如果缺少了同源策略，浏览器很容易受到 XSS、 CSFR 等攻击。 4.2、如何解决跨域 4.2.1、前端解决 前端项目如果是 vue 项目，可以在 vue 的全局配置文件vue.config.js 中进行配置，将需要访问的后端地址进行代理，从安全方面考虑，推荐这样做，具体配置如下： 123456789101112131415161718const define = require(&quot;./src/util/define&quot;)// define 是自己定义的一些全局配置变量，便于管理module.exports = &#123; // 去除代码规范 lintOnSave: false, devServer: &#123; proxy: &#123; &quot;/api&quot;: &#123; target: define.APIURL, // define.APIURL 就是你后端服务的地址 ws: true, changeOrigin: true, pathRewrite: &#123; &#x27;^/api&#x27;: &#x27;&#x27; &#125; &#125; &#125; &#125;&#125; 4.2.2、后端解决 后端我使用的 spring 版本是 4.0 以上的，所以配置跨域很简单，只需要在相应的控制器或方法上加上注解 @CrossOrigin(origins = &#123;&quot;http://localhost:8080&quot;&#125;)。 你也可以直接使用 @CrossOrgin 来进行配置，但是这样所有的访问地址都可以访问到你的服务，不安全。同时，这个注解也可以放在方法上，表示这个方法单独可以被访问。 关于后端解决跨域的方式还有其他途径，比如全局配置拦截器，这里再不做细讲。 5、ssm 重要的配置文件 Pom.xml 依赖配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.cxsw&lt;/groupId&gt; &lt;artifactId&gt;rmsService&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;rmsService&lt;/name&gt; &lt;!--FIXME change it to the project&#x27;s website--&gt; &lt;url&gt;http://localhost:3000&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- 测试相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.3.22&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring 相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.22&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.22&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 事务相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.3.22&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.3.22&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.9.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据层相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.30&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.20&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 实体代码生成工具 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.24&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 整合 mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jackson --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.13.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.13.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.13.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 文件上传相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.11.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.36&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;port&gt;3000&lt;/port&gt; &lt;path&gt;/&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; ApplicationContext.xml (spring 核心配置文件) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;!-- 组建扫描 --&gt; &lt;context:component-scan base-package=&quot;com.cxsw.rms&quot;&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;/context:component-scan&gt; &lt;!-- 配置数据源 --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;druid.jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;druid.jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;druid.jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;druid.jdbc.password&#125;&quot;/&gt; &lt;/bean&gt; &lt;!-- 整合 mybtis --&gt; &lt;bean id=&quot;sqlSessionFactoryBean&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis.xml&quot;/&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:/mappers/*.xml&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;sqlSessionTemplate&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt; &lt;constructor-arg ref=&quot;sqlSessionFactoryBean&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;mapperScannerConfigurer&quot; class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.cxsw.rms.repository&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置声明式事务控制 --&gt; &lt;bean id=&quot;dataSourceTransactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;dataSourceTransactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;insert*&quot;/&gt; &lt;tx:method name=&quot;delete*&quot;/&gt; &lt;tx:method name=&quot;update*&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;aop:config&gt; &lt;aop:pointcut id=&quot;pointCut&quot; expression=&quot;execution(* com.cxsw.rms.service.impl.*.*(..))&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pointCut&quot;/&gt; &lt;/aop:config&gt;&lt;/beans&gt; SpringMVC.xml （springMVC 的核心配置文件） 123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 配置组建扫描 --&gt; &lt;context:component-scan base-package=&quot;com.cxsw.rms.controller&quot; /&gt; &lt;!-- 配置注解驱动 --&gt; &lt;mvc:annotation-driven /&gt; &lt;bean id=&quot;dateConverter&quot; class=&quot;com.cxsw.rms.convert.DateConverter&quot; /&gt; &lt;bean class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot; id=&quot;conversionService&quot;&gt; &lt;property name=&quot;converters&quot; ref=&quot;dateConverter&quot; /&gt; &lt;/bean&gt; &lt;!-- 时间转换驱动 --&gt; &lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;/&gt; &lt;!-- 配置文件上传解析器 --&gt; &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;52128800&quot; /&gt; &lt;property name=&quot;maxUploadSizePerFile&quot; value=&quot;52128800&quot;/&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;/&gt; &lt;/bean&gt; &lt;mvc:default-servlet-handler /&gt;&lt;/beans&gt; Mybatis 配置文件（ssm 集成之后可以不需要此配置文件，个人习惯而已） 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- 替换全限定名 --&gt; &lt;typeAliases&gt; &lt;typeAlias type=&quot;com.cxsw.rms.entity.User&quot; alias=&quot;user&quot;/&gt; &lt;typeAlias type=&quot;com.cxsw.rms.entity.Student&quot; alias=&quot;student&quot;/&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; 数据库的配置文件 ✅ 注意 mysql 的版本，如果是 8.0 驱动包是 com.mysql.cj.jdbc.Driver，5.0 版本的驱动包在 com.mysql.jdbc.Driver 下。导入依赖的时候格外要注意。 1234druid.jdbc.driver=com.mysql.cj.jdbc.Driverdruid.jdbc.url=jdbc:mysql://localhost:3306/rms?useUnicode=true&amp;characterEncoding=utf-8druid.jdbc.username=rootdruid.jdbc.password=wb7446032001 Mapper 文件（示例） 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.cxsw.rms.repository.StudentMapper&quot;&gt; &lt;resultMap id=&quot;studentMap&quot; type=&quot;student&quot;&gt; &lt;id property=&quot;sid&quot; column=&quot;SID&quot; /&gt; &lt;result property=&quot;name&quot; column=&quot;NAME&quot; /&gt; &lt;result property=&quot;nation&quot; column=&quot;NATION&quot; /&gt; &lt;result property=&quot;idCard&quot; column=&quot;ID_CARD&quot; /&gt; &lt;result property=&quot;region&quot; column=&quot;REGION&quot; /&gt; &lt;result property=&quot;education&quot; column=&quot;EDUCATION&quot; /&gt; &lt;result property=&quot;school&quot; column=&quot;SCHOOL&quot; /&gt; &lt;result property=&quot;major&quot; column=&quot;MAJOR&quot; /&gt; &lt;result property=&quot;educationType&quot; column=&quot;EDUCATION_TYPE&quot; /&gt; &lt;result property=&quot;email&quot; column=&quot;EMAIL&quot; /&gt; &lt;result property=&quot;phone&quot; column=&quot;PHONE&quot; /&gt; &lt;result property=&quot;employeeUnit&quot; column=&quot;EMPLOYEE_UNIT&quot; /&gt; &lt;result property=&quot;registerBook&quot; column=&quot;REGISTER_BOOK&quot; /&gt; &lt;result property=&quot;diploma&quot; column=&quot;DIPLOMA&quot; /&gt; &lt;result property=&quot;creatTime&quot; column=&quot;CREAT_TIME&quot; /&gt; &lt;/resultMap&gt; &lt;insert id=&quot;insertStudent&quot; parameterType=&quot;student&quot;&gt; INSERT INTO STUDENTS (`SID`, `NAME`, NATION, ID_CARD, REGION, EDUCATION, SCHOOL, MAJOR, EDUCATION_TYPE, EMAIL, PHONE, EMPLOYEE_UNIT, REGISTER_BOOK, DIPLOMA, CREAT_TIME) VALUE ( #&#123;sid&#125;, #&#123;name&#125;, #&#123;nation&#125;, #&#123;idCard&#125;, #&#123;region&#125;, #&#123;education&#125;, #&#123;school&#125;, #&#123;major&#125;, #&#123;educationType&#125;, #&#123;email&#125;, #&#123;phone&#125;, #&#123;employeeUnit&#125;, #&#123;registerBook&#125;, #&#123;diploma&#125;, #&#123;creatTime&#125; ) &lt;/insert&gt;&lt;/mapper&gt; 6、后端三层架构示例 持久层和实体类 映射数据库字段的实体个人建议使用 Lombok 代码生成器，这样你在修改字段的时候就不用来回手动生成 get set tostring …… 等方法了。 用法如下： 在你的依赖文件中导入 Lombok 的依赖坐标。 12345&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.24&lt;/version&gt;&lt;/dependency&gt; 在你 idea 中的插件商店里边下载 Lombok 插件，不然代码生成不起作用，切记！！！ 在你的实体类里边配置注解，注解具体解释如下： ✅ @Data 用于生成 get set hashCode toString 等方法 @AllArgsConstructor 生成全参数的构造法昂发 @NoArgsConstructor 生成无参数的构造方法 通过上图就可以发现，在单独写了实体字段的情况下，通过注解就可以自动生成代码。 持久层的接口：这里以新增数据的某个接口示例 1234567891011121314/** * 信息登记数据层 * @author zhangsan * @date 2022-08-25 */public interface StudentMapper &#123; /** * 新增信息登记 * @param student 信息登记对象 * @return 0 代表新增失败 反之成功 */ int insertStudent(Student student);&#125; 对应的 mapper（由于新增字段有点多，没有使用 mybatis 的注解来写 sql） 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.cxsw.rms.repository.StudentMapper&quot;&gt; &lt;!-- 这里的 student 是我在 mybtais 中配置的别名 --&gt; &lt;insert id=&quot;insertStudent&quot; parameterType=&quot;student&quot;&gt; INSERT INTO STUDENTS (`SID`, `NAME`, NATION, ID_CARD, REGION, EDUCATION, SCHOOL, MAJOR, EDUCATION_TYPE, EMAIL, PHONE, EMPLOYEE_UNIT, REGISTER_BOOK, DIPLOMA, CREAT_TIME) VALUE ( #&#123;sid&#125;, #&#123;name&#125;, #&#123;nation&#125;, #&#123;idCard&#125;, #&#123;region&#125;, #&#123;education&#125;, #&#123;school&#125;, #&#123;major&#125;, #&#123;educationType&#125;, #&#123;email&#125;, #&#123;phone&#125;, #&#123;employeeUnit&#125;, #&#123;registerBook&#125;, #&#123;diploma&#125;, #&#123;creatTime&#125; ) &lt;/insert&gt;&lt;/mapper&gt; 业务层（由于业务不是很复杂，就是简单的数据处理，所以业务层就是调用持久层的接口返回数据） 1234567891011121314/** * 信息填报接口业务逻辑层*@author zhangsan *@date 2022-08-26 */public interface StudentService &#123; /** * 新增信息登记 * @param student 信息登记对象 * @return 0 代表新增失败 反之成功 */ String insertStudent(Student student);&#125; 实现类： 12345678910111213141516171819202122232425262728293031323334/** * 信息填报业务层实现 * @author zhangsan * @date 2022-08-26 */@Servicepublic class StudentServiceImpl implements StudentService &#123; @Resource private StudentMapper studentMapper; /** * 新增信息登记 * @param student 信息登记对象 * @return 0 代表新增失败 反之成功 */ @Override public String insertStudent(Student student) &#123; Date date = new Date(new java.util.Date(System.currentTimeMillis()).getTime()); student.setCreatTime(date); studentMapper.insertStudent(student); List&lt;Student&gt; students = studentMapper.listStudents(student.getName(), &quot;&quot;); User user = new User(); user.setUsername(student.getName()); user.setSid(students.get(0).getSid()); int res = userMapper.updateUserForeignKey(user); if(res == 0)&#123; return &quot; 新增失败 &quot;; &#125;else&#123; return &quot; 新增成功 &quot;; &#125; &#125;&#125; 控制层 12345678910111213141516171819202122232425262728293031/** * 信息填报接口 * @author zhangsan * date 2022-08-26 */@RestController@RequestMapping(value = &quot;/student&quot;)public class StudentController &#123; @Resource private StudentService studentService; /** * 新增信息填报接口 * @param student 学生对象 * @return result 对象 */ @PostMapping public Result createStudentList(@RequestBody Student student)&#123; if(student == null)&#123; return new Result(500, &quot; 上报信息不全 &quot;, null); &#125;else&#123; String msg = studentService.insertStudent(student); return new Result(200, &quot; 操作成功 &quot;, msg); &#125; &#125;&#125; ✅ 😁这就完成后端的一个接口了，紧接着测试完就可以将接口交给前端了，在这里，个人建议写接口写类的时候一定要写好 javadoc 文档注释 ，这样方便后来者查看，我写代码的时候一定会这样想： 代码是写给别人看的，不是写给自己看的，所以一定要简洁明了。 7、前端使用接口 ✅ 前端我使用的是 axios 发送请求，并对请求做了简单封装。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import axios from &quot;axios&quot;;// message 是自己对 element-ui 总的消息提示框进行的封装，防止其重复弹出import &#123; message &#125; from &quot;@/util/message&quot;// 拦截响应axios.interceptors.response.use( response =&gt; &#123; if (!response?.data) return; const res = response.data; if (res.code !== 200) &#123; message(&#123; message: res.msg || &#x27; 请求出错，请重试 &#x27;, type: &quot;error&quot;, duration: 1500, onClose: () =&gt; &#123; // 消息框退出时需要处理的逻辑 &#125; &#125;) &#125; else &#123; return res; &#125; &#125;, error =&gt; &#123; message(&#123; message: &quot; 请求出错，请重试 &quot;, type: &quot;error&quot;, duration: 1500 &#125;) // 返回错误 return Promise.reject(error) &#125;)// 封装请求const request = async (&#123; url, method, data, headers &#125;) =&gt; &#123; const type = method.toLocaleUpperCase(); if (type === &#x27;GET&#x27;) &#123; return await new Promise((res, rej) =&gt; &#123; getRequest(url, data, res, rej) &#125;) &#125; else if (type === &#x27;POST&#x27;) &#123; return await new Promise((res, rej) =&gt; &#123; postRequest(url, data, headers, res, rej) &#125;) &#125; else if (type === &#x27;PUT&#x27;) &#123; return await new Promise((res, rej) =&gt; &#123; putReqeust(url, data, res, rej) &#125;) &#125; else &#123; return await new Promise((res, rej) =&gt; &#123; deleteRequest(url, res, rej) &#125;) &#125;&#125;// get 请求const getRequest = (url, datas, res, rej) =&gt; &#123; axios.get(url, &#123; params: datas &#125;).then((data) =&gt; &#123; res(data) &#125;).catch((error) =&gt; &#123; rej(error) &#125;)&#125;// put 请求const putReqeust = (url, datas, res, rej) =&gt; &#123; axios.put(url, datas).then((data) =&gt; &#123; res(data) &#125;).catch((error) =&gt; &#123; rej(error) &#125;)&#125;// delete 请求const deleteRequest = (url, res, rej) =&gt; &#123; axios.delete(url).then((data) =&gt; &#123; res(data) &#125;).catch((error) =&gt; &#123; rej(error) &#125;)&#125;// post 请求const postRequest = (url, datas, headers, res, rej) =&gt; &#123; axios.post(url, datas, headers).then((data) =&gt; &#123; res(data) &#125;).catch((error) =&gt; &#123; rej(error) &#125;)&#125;export default request; message 的封装如下： 1234567891011121314151617181920212223import &#123; Message &#125; from &#x27;element-ui&#x27;let messageInstance = null;// 防止重复弹出消息提示const resetMessage = (options) =&gt; &#123; if (messageInstance) &#123; messageInstance.close() &#125; messageInstance = Message(options)&#125;;let tipType = [&quot;error&quot;, &quot;info&quot;, &quot;success&quot;, &quot;warning&quot;];tipType.forEach(type =&gt; &#123; resetMessage[type] = options =&gt; &#123; if (typeof options === &quot;string&quot;) &#123; options = &#123; message: options &#125; &#125; options.type = type return resetMessage(options) &#125;&#125;)export const message = resetMessage 在 src 下构建目录 api 用于统一管理接口： 12345678910import request from &quot;@/util/request&quot;;// * 新增信息登记export const addStudnetMsg = (data) =&gt; &#123; return request(&#123; url: &quot;/api/student&quot;, method: &quot;POST&quot;, data &#125;)&#125; 在相应的页面中调用接口： 123456789101112131415161718192021222324252627282930313233343536373839404142// 导入 apiimport &#123; updateStudentMsg, addStudnetMsg &#125; from &quot;@/api/student&quot;// 表单提交方法 submitForm(formName) &#123; this.$refs[formName].validate((valid) =&gt; &#123; if (valid) &#123; // 根据你实际的页面 调用接口 const formMethod = this.ruleForm.sid ? updateStudentMsg : addStudnetMsg; this.ruleForm.region = this.ruleForm.region[0] + &quot;-&quot; + this.ruleForm.region[1] + &quot;-&quot; + this.ruleForm.region[2] formMethod(this.ruleForm).then((data) =&gt; &#123; if (data?.code === 200) &#123; message(&#123; type: &quot;success&quot;, message: data.msg, duration: 1500, onClose: () =&gt; &#123; this.ruleForm.registerBook = &#x27;&#x27; this.ruleForm.diploma = &#x27;&#x27; this.$router.push(&quot;/&quot;); // 更新用户信息 if (!this.ruleForm.sid) &#123; let params = &#123; username: sessionUtils.get(&#x27;token&#x27;).username &#125;; listUsers(params).then((data) =&gt; &#123; if (data?.code === 200) &#123; data.data[0].password = &quot;&quot;; sessionUtils.set(&quot;token&quot;, data.data[0], 1000 * 60 * 60 * 6) // 将数据存储到 vuex 中 this.$store.dispatch(&quot;userInfo/getUserInfo&quot;, data.data[0]); &#125; &#125;) &#125; &#125; &#125;) &#125; &#125;) &#125; else &#123; return false; &#125; &#125;); 😜至此，一个接口通了。 8、源码地址 前端 gitee 地址：https://gitee.com/wenjingxin/rms.git 后端 gitee 地址：https://gitee.com/wenjingxin/ssm.git 😁 分享不易，希望多多支持 🤝","categories":[{"name":"编程艺术","slug":"编程艺术","permalink":"https://wenjing-xin.github.io/categories/%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/"}],"tags":[{"name":"前后端分离","slug":"前后端分离","permalink":"https://wenjing-xin.github.io/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"}],"author":"稳静逐梦"}],"categories":[{"name":"运维","slug":"运维","permalink":"https://wenjing-xin.github.io/categories/%E8%BF%90%E7%BB%B4/"},{"name":"前端","slug":"前端","permalink":"https://wenjing-xin.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Java","slug":"Java","permalink":"https://wenjing-xin.github.io/categories/Java/"},{"name":"思考","slug":"思考","permalink":"https://wenjing-xin.github.io/categories/%E6%80%9D%E8%80%83/"},{"name":"随笔记录","slug":"随笔记录","permalink":"https://wenjing-xin.github.io/categories/%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95/"},{"name":"编程艺术","slug":"编程艺术","permalink":"https://wenjing-xin.github.io/categories/%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/"},{"name":"工具集合","slug":"工具集合","permalink":"https://wenjing-xin.github.io/categories/%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://wenjing-xin.github.io/tags/docker/"},{"name":"容器化部署技术","slug":"容器化部署技术","permalink":"https://wenjing-xin.github.io/tags/%E5%AE%B9%E5%99%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E6%8A%80%E6%9C%AF/"},{"name":"杂谈","slug":"杂谈","permalink":"https://wenjing-xin.github.io/tags/%E6%9D%82%E8%B0%88/"},{"name":"web","slug":"web","permalink":"https://wenjing-xin.github.io/tags/web/"},{"name":"JavaSE","slug":"JavaSE","permalink":"https://wenjing-xin.github.io/tags/JavaSE/"},{"name":"随笔","slug":"随笔","permalink":"https://wenjing-xin.github.io/tags/%E9%9A%8F%E7%AC%94/"},{"name":"亲情","slug":"亲情","permalink":"https://wenjing-xin.github.io/tags/%E4%BA%B2%E6%83%85/"},{"name":"世界","slug":"世界","permalink":"https://wenjing-xin.github.io/tags/%E4%B8%96%E7%95%8C/"},{"name":"情感","slug":"情感","permalink":"https://wenjing-xin.github.io/tags/%E6%83%85%E6%84%9F/"},{"name":"程序人生","slug":"程序人生","permalink":"https://wenjing-xin.github.io/tags/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"},{"name":"CS","slug":"CS","permalink":"https://wenjing-xin.github.io/tags/CS/"},{"name":"接口风格","slug":"接口风格","permalink":"https://wenjing-xin.github.io/tags/%E6%8E%A5%E5%8F%A3%E9%A3%8E%E6%A0%BC/"},{"name":"Restful","slug":"Restful","permalink":"https://wenjing-xin.github.io/tags/Restful/"},{"name":"git","slug":"git","permalink":"https://wenjing-xin.github.io/tags/git/"},{"name":"版本控制","slug":"版本控制","permalink":"https://wenjing-xin.github.io/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"前后端分离","slug":"前后端分离","permalink":"https://wenjing-xin.github.io/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"}]}